---
title: "Data scientist's primer to analysis of mass cytometry data"
author: "Contributors: Lars Rønn Olsen, Christina Bligaard Pedersen, Mike Leipold, and Holden Maecker"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

# Preamble
## The purpose of this site
The aim of this site is to introduce cytometry data - specifically mass cytometry data - to data scientists and bioinformaticians not familiar with the technology, the unique challenges relating to the technical and biological origins of the data. The content will be updated periodically as new tools and methods are published.

Along with discussions, we have included code for common processing and analysis tasks for R. Flow cytometry as a scientific discpline has been around for half a century at this point, and a plethora of software and data analysis packages has been created using a multitude of different programming languages. Common to the majority of them, is the heavy focus on the use of The Flow Cytometry Standard (FCS) format. While this format certainly has its strengths, it (and the analysis software developed for it) can seem somewhat convoluted to the uninitiated. Rather than attempting to update these packages for mass cytometry or introduce workarounds, we here focus on extracting and working with the raw expression matrices that most bioinformaticians know from other data types - such as for example transcriptomics (probe and sequence-based alike). The rationale is that once a bioinformatician has an expression matrix and a working understanding of the technical and biological idiosyncracies of the data, most, if not all, common analysis algorithms for expression data can be adapted and applied.

We will also present a selection of common analysis tools. Not with the explicit purpose of applying them in their packaged form, but to explain what goes on under the hood to enable these useful analyses to be applied in a more flexible and customizable way. The main aim here is enabling a high level of autonomy for data scientists working with mass cytometry data by dissecting both the data and common algorithms to its core workable components.

The site consists of a series of code snippets for preparing and analyzing the data. The entire collection of scripts without can be downloaded [here] (https://raw.githubusercontent.com/biosurf/CyTOF/master/primer.R). The examples are based on 21 FCS files from healthy control individuals (described below and available from [flowrepository](http://flowrepository.org/experiments/1363/download_ziped_files)). Save the files locally and replace the paths in the code below to work with the example data or use your own data.

## The example data sets
### Healthy donor samples
21 samples of PBMC from healthy control individuals, stained with the [Leipold and Maecker 2015 protocol](http://www.bio-protocol.org/e1382), mixed with EQ normalization beads (Fluidigm Corp), and acquired on a Fluidigm CyTOF Helios mass cytometer using default acquisition parameters. The data exists in two forms: 1) the raw FCS files as generated by the Helios, 2) the samples normalized using the MATLAB method (described in [section 2.1](#beadnorm)) - these are files with \"normalized\" in the file name. Each row in the expression matrix is an event, of which we are only interested in those that represent live, intact, singlet cells (i.e. we want to filter out beads, dead cells, doublets, debris, etc.). Each column contains information about the cells - some are parameters from the data collection by the instrument (e.g. event length, time, etc.), some are markers primarily used for pre-gating (DNA stain, live/dead stain, beads, etc.), some are lineage markers (needed to determine the cell type), and some are activation or cell state makers. <show-table data-table=\"HIMCControlsMarkers\">Here is a table</show-table> with descriptions of each column in the example expression files.

| Isotope   | Parameter | Description|
|:-----------|:-----------|:---------------------------------------------------------------------------------------------------------------------------------|
| Ce140Di   | Bead      | **Normalization parameter** isotope unique to Fluidigm EQ normalization beads; used to distinguish them from cells during gating |
| In115Di   | Dead      | **Pre-gating parameter** Maleimide-DOTA small molecule as live-dead (cannot efficiently enter cells with undisturbed membranes) |
| Ir191Di   | DNA1      | **Pre-gating parameter** DNA intercalator (intact cells have high levels)|
| Ir193Di   | DNA2      | **Pre-gating parameter** DNA intercalator (intact cells have high levels)|
| Nd142Di   | CD19      | **Lineage marker** B cell marker|
| Nd146Di   | IgD       | **Lineage marker** B cell marker|
| Dy164Di   | CD20      | **Lineage marker** B cell marker|
| Nd143Di   | CD4       | **Lineage marker** T cell marker|
| Nd144Di   | CD8       | **Lineage marker** T cell marker|
| Nd148Di   | CD11c     | **Lineage marker** used to gate mDCs                                                                                            |
| Sm149Di   | CD16      | **Lineage marker** used mostly to gate NK cells                                                                                 |
| Nd150Di   | CD3       | **Lineage marker** used to gate T cells                                                                                         |
| Sm154Di   | CD14      | **Lineage marker** used to gate Monocytes                                                                                       |
| Gd155Di   | CCR6      | **Lineage marker** used to gate Th1/Th2/Th17 cells                                                                              |
| Gd158Di   | CXCR5     | **Lineage marker** used to gate T follicular helper cells                                                                       |
| Tb159Di   | CXCR3     | **Lineage marker** used to gate Th1/Th2/Th17 cells                                                                              |
| Gd160Di   | CCR7      | **Lineage marker** used to gate Naive/Central memory/Effector memory/Effector T cells                                           |
| Dy162Di   | CD45RA    | **Lineage marker** used to gate Naive/Central memory/Effector memory/Effector T cells                                           |
| Ho165Di   | CD127     | **Lineage marker** used to gate Tregs                                                                                           |
| Er166Di   | CD33      | **Lineage marker** used to gate Monocytes                                                                                       |
| Er168Di   | CD24      | **Lineage marker** used to gate Transitional B cells                                                                            |
| Yb171Di   | TCRgd     | **Lineage marker** used to gate gamma-delta T cells                                                                             |
| Yb173Di   | CD123     | **Lineage marker** used to gate basophils and pDCs                                                                              |
| Yb174Di   | CD56      | **Lineage marker** used to gate NK cells and NKT cells                                                                          |
| Yb176Di   | CD25      | **Lineage marker** used to gate Tregs                                                                                           |
| Lu175Di   | HLADR     | **General protein marker** activation marker on NK and T cells                                               |
| In113Di   | CD57      | **General protein marker** differentiation marker found on CD8+ T cells and NK cells                                            |
| Yb172Di   | PD-1      | **General protein marker** found on T cells, modulates immune function                                                          |
| Tm169Di   | ICOS      | **General protein marker** found on T cells, modulates immune function                                                          |
| Er170Di   | CD161     | **General protein marker** marker of IL17 producing T cells                                                                     |
| Er167Di   | CD28      | **General protein marker** found on T cells, necessary for immune activation                                                    |
| Gd156Di   | CD94      | **General protein marker** found on CD8+ T cells and NK cells, modulates immune function                                        |
| Gd157Di   | CD86      | **General protein marker** found on T cells, necessary for immune activation and survival                                       |
| Eu151Di   | CD38      | **General protein marker** found on T cells, B cells, and NK cells, necessary for immune function                               |
| Sm152Di   | CD27      | **General protein marker** found on B and T cells, involved in modulation and activation of immune function                     |
| Eu153Di   | CD11b     | **General protein marker** found on cell of the innate immune system                                                            |
| Sm147Di   | CD85j     | **General protein marker** found on T cells, regulates immune activation                                                        |
| BCKG190Di | 190BCKG   | **Background** not used in gating                                                                                               |
| Pb208Di   | 208Pb     | **Background** not used in gating                                                                                               |
| Sn120Di   | 120Sn     | **Background** not used in gating                                                                                               |
| I127Di    | 127I      | **Background** not used in gating                                                                                               |
| Xe131Di   | 131Xe     | **Background** not used in gating                                                                                               |

An R data object with the pre-processed healthy control samples (normalized, pre-gated, transformed - the entire process is detailed below) can be downloaded [here](https://github.com/biosurf/CyTOF/raw/master/biosurf/cytof/live.Rdata) if you are mostly interested in post-processing analyses. If so, you may skip to [section 3](#analysistasks).

### Case/control samples
To exemplify analysis of differential abundance, we also use a case/control dataset. We here use the data described by [Bodenmiller et al](https://www.nature.com/nbt/journal/v30/n9/full/nbt.2317.html), which consists of 8 samples of PBMC responding to B-cell receptor (BCR)/Fc receptor (FCR) cross-linking and 8 control PBMC samples. The raw data can be downloaded [here](https://www.cytobank.org/cytobank/experiments/15713/download_files) (download the files with \"reference\" and \"BCR-XL\" in the filename). These data are pregated and transformed. 

## Installing the R packages you will need
We use a variety of packages for the analyses below. In case you are missing some of them, here's what you will need:

```r
## From CRAN
install.packages(c(\"scales\", \"RColorBrewer\", \"MASS\", \"Rtsne\", \"kohonen\", \"miscTools\", \"gplots\", \"Radviz\", \"igraph\", \"statmod\"))

## From BioConductor
source(\"https://bioconductor.org/biocLite.R\")
biocLite(c(\"flowCore\", \"cytofkit\", \"ConsensusClusterPlus\", \"cydar\", \"flowCL\", \"CATALYST\", \"ncdfFlow\", \"edgeR\"))

## From source
# cytofCore
library(devtools)
install_github(\"nolanlab/cytofCore\")

# MEM
library(devtools)
download.file(url = \"http://www.nature.com/nmeth/journal/v14/n3/extref/nmeth.4149-S5.zip\", destfile = \"./MEM.zip\")
unzip(\"MEM.zip\")
setwd(\"./MEM\")
build()
install.packages(\"./\", repos = NULL, type=\"source\")
unlink(\"../MEM/\", recursive = TRUE) # optional cleanup
```

The R session info is located at the [bottom of the page](#sessioninfo).","content":"# The structure of data from the CyTOF system
The following sections include lots of code snippets. The entire raw code can be downloaded [here](https://raw.githubusercontent.com/biosurf/CyTOF/master/primer.R).
## The Flow Cytometry Standard (FCS) format {FCS}

The FCS format is a binary data file standard originally developed for storage of flow cytometry data. As well as the ion count matrix, it has slots for experiment information, channel information, etc. Traditionally, ion counts have been analyzed visually using [FlowJo](https://www.flowjo.com/solutions/flowjo) - a commercial software platform for analysis of single-cell cytometry experiments. FlowJo is largely GUI-based and requires a license for both academic and non-academic users. For more automated analysis, the following tools for R can be used to import, manipulate and convert FCS files - or
extract the ion counts for downstream analysis in R or other programming environments.

* [flowCore](http://bioconductor.org/packages/release/bioc/html/flowCore.html): facilitates many FCS file related functions. Includes the option to write new FCS files.
* [flowStats](https://www.bioconductor.org/packages/release/bioc/html/flowStats.html): package for normalizing, gating, and basic and advanced analyses of flow cytometry data.
* [cytofCore](https://github.com/nolanlab/cytofCore): contains a function to merge FCS files from disrupted CyTOF runs.
* [CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html): contains functions for normalization, debarcoding, and quality control.

Example of basic FCS file handling:

```r
# Load the flowCore package
library(flowCore)

# Set working directory (directory where you placed the FCS files)
setwd(\"~/cytof_primer/healthy_controls/fcs_files/\")

# Read an fcs file
fcs_files <- list.files(pattern='.fcs$', full=TRUE, ignore.case = TRUE)
fcs <- read.FCS(filename=fcs_files[1], transformation=FALSE)

# Extract expression matrix
exprs <- fcs@exprs

# Explore the channels (columns in the expression matrix)
fcs@parameters@data

# Make colnames human readable using information in the parameter data slot
markers <- gsub(pattern = \".*_\", replacement = \"\", x = as.vector(fcs@parameters@data$desc))
colnames(exprs)[which(!is.na(markers))] <- markers[which(!is.na(markers))]

# Merging fcs files (in case of interrupted runs)
library(cytofCore)
dir.create(\"./combined\")
cytofCore.concatenateDirectoryFiles(inputDir=\"./\",outputDir=\"./combined\",pattern=NULL,overwrite=F,timeParam=\"time\")
```

## Parameter harmonization {harmonize}
Note that these channels are **freetext editable** in the Fluidigm CyTOF software. This means that if you are dealing with files from multiple different runs from different instruments and/or different operators (or in some cases even different staining panels), you will need to **harmonize your channel names** to compare samples. The mass information (in the \"name\" column) is *usually* the most reliable, but even here errors can occur. When in doubt, consult with the operator before renaming the channels.

# Data preprocessing
Preprocessing is essential in any mass cytometry analysis process. Key steps in preprocessing include: **bead normalization**, in which one adjusts for varying instrument performance over time; **pre-gating**, in which live intact singlet cells are obtained; **compensation**, which (if applicable) is used to correct for spillover between the signals of different heavy metal isotopes, and **debarcoding**, which (if applicable) is used to separate different samples in a multiplexed experiment.

For convenience, we here define the different types of channels (columns in the data matrix) used for different purposes:

```r
pregating_channels <- c(\"Bead\", \"DNA1\", \"DNA2\", \"Dead\", \"Event_length\")
lineage_channels <- c(\"CD57\", \"CD19\", \"CD4\", \"CD8\", \"IgD\", \"CD11c\", \"CD16\", \"CD3\", \"CD38\", \"CD27\", \"CD14\", \"CXCR5\", \"CCR7\", \"CD45RA\", \"CD20\", \"CD127\", \"CD33\", \"CD28\", \"CD161\", \"TCRgd\", \"CD123\", \"CD56\", \"HLADR\", \"CD25\")
instrument_channels <- c(\"Time\", \"Event_length\", \"Center\", \"Offset\", \"Width\", \"Residual\", \"sample\")
```

## Bead Normalization {beadnorm}
Because CyTOF  instrument performance may vary over time (both within a single run, but more prominently between different runs), it is important to normalize data in a way that limits the impact of the technical variation. The most commonly employed methods are the Fluidigm normalization (DVS Sciences, 2013) and MATLAB normalization ([Finck et al., 2013](https://doi.org/10.1002/cyto.a.22271)). Both methods are based on adding beads carrying different heavy metal isotopes to the biological sample, and relying on the beads to leave an extractable signature that can be used to correct signal fluctuations. The Fluidigm normalization method uses a bead \"passport\" to normalize data to a global standard, while the MATLAB method normalizes using median bead intensities calculated across given experimental data files (e.g. files from different runs on the same machine). 

### Fluidigm bead normalization
The Fluidigm bead normalization method is based on the calculation of the mean isotope counts of the beads during production. This global bead profile, called the “Bead Passport”, is unique to each lot of beads synthesized and cannot be adjusted by the user. The first step in the normalization process is for the software to distinguish the beads from the cell sample in question. This is performed using all the major isotopes of the beads (Ce140, Eu151, Eu153, Ho165, and Lu175 for the current Fluidigm EQ beads). The normalization factor is calculated as the ratio between the Bead Passport and the measured counts for each of the beads. The bead channels span a large range of the mass spectrum, and using linear interpolation to masses between or beyond the bead masses allows for the calculation of normalization factors that are then multiplied to each remaining mass channel distributed across the course of the run using the time stamp. This allows for correction of decline in instrument sensitivity during the course of running a sample, and also normalization across samples (see figure below). However, if the instrument used to acquire a sample differs from the Bead Passport in overall signal intensity or in sensitivity across the mass range, the Fluidigm normalization will “force” the sample data to conform to the shape and signal of the Passport (see Figure 4, especially CyTOFv1 red line).

### MATLAB bead normalization (Finck et al.)
The MATLAB implemented normalization algorithm created by [Finck et al. (2013)](https://doi.org/10.1002/cyto.a.22271) works by modelling the sample specific drift in count reporting. Briefly, bead singlets are manually identified by biaxial gating of each of the five bead channels against a DNA channel. The intensities of each bead channel over the course of a sample run, are smoothed by calculating local medians in a 500 bead event sliding window. Then, a baseline is calculated by taking the mean of the smoothed intensities for each bead channel. For each bead channel, for each time point, the slope of the linear regression from the channel origin to the given time point is calculated, such that the residual sum of squares between the smoothed bead intensities and the baseline is minimized. For each recorded event, the intensity is multiplied by the slope of corresponding the time point at which is was recorded. Since the MATLAB normalization compares each file to the other files rather than to an externally-determined set of values, there is typically less “forcing” or reshaping of the data than in Fluidigm normalization (see figure below).

![The effects of normalization on Raw data](https://i.imgur.com/ATkadu0.png)

The effects of normalization on Raw data is shown above. Replicate samples were stained, then pooled and split into individual aliquots before freezing in FBS+10% DMSO at -80°C as Takahashi et al. On each day, the sample was thawed on ice, washed 3x in MilliQ water, then resuspended in MilliQ water containing Fluidigm EQ beads and acquired on the indicated CyTOF instrument model. The CyTOFv2 was later upgraded to the v2-to-Helios instrument and another aliquot was run. During data analysis, the EQ beads were gated separately from the cells. The linear y-axis represents the Median Di Dual signal intensity of the indicated mass channel: the Bead data is shown in the top row, while the Cell data is shown on the bottom row (marker on indicated cell population). While the Beads and Cells cover a similar mass range, the signal intensity of the Cells on a specific instrument changes depending on the normalization method (Raw vs. Fluidigm-ver2 vs. MATLAB).

It should be noted that although the bead normalization is useful for adjusting for signal changes due primarily to the instrument performance, it does have some limitations. First, there may be some decrease in signal intensity in the sample that is not reflected in the bead signal. For example, while proper fixation does generally allow cells to withstand the osmotic force of MilliQ water, users have reported decreases in signal intensity during acquisition of large volume barcoded samples. Since the beads are not affected by lengthy suspension in water, the bead signals would not change in the same way that cell signals may. Generally, samples fixed with paraformaldehyde seem more robust than those fixed only with commercial fix/perm solutions. Additionally, samples are typically more stable as pellets. Therefore, this sample signal decrease can often be limited by breaking one large sample into aliquots that would each make 3-5 mL of diluted sample, and only resuspending the pellet of each aliquot shortly before collection. Second, since the beads are not stained with the assay reagents, they are seldom sufficient for true plate-to-plate batch correction, particularly over long periods of time when reagent lots could change.

### Performing bead normalization
Because the MATLAB method is more commonly used in practice, it is the focus on this wiki. The MATLAB normalization method is implemented with a graphical user interface (GUI), in which the user manually gates the beads using five different bi-axial plots in which each bead metal is plotted against the iridium channel (that measures DNA). This can be installed from [here](https://github.com/nolanlab/bead-normalization/wiki/Installing-the-Normalizer). 

While wet lab scientists are accustomed to working with manual gating and GUIs, such as the one in the MATLAB normalization program, this is not the preferred method for data scientists such as bioinformaticians, who commonly wish to analyze a large number of samples, making manual gating very cumbersome. As a consequence, we implemented the MATLAB normalization algorithm in R, such that it may be called from the command-line and run completely without user interference. This process was carried out by translating the MATLAB source code (available from [here](https://github.com/nolanlab/bead-normalization)) and making small alterations. The R version can be downloaded from our [Github repository](https://github.com/biosurf/CyTOF/blob/master/MATLAB_normalization.R). 

The biggest change from the original version is the fact that bead gating is carried out automatically in the R version using a Support Vector Machine (SVM), which was trained for this specific purpose, using the signals of five bead channels and the DNA channel for a total of seven data sets, for which beads had been gated manually by an experienced wet-lab scientist. The SVM was trained in R using svm from the [e1071 package](https://cran.r-project.org/web/packages/e1071/). The training data was seven samples, each comprising of 250,000 events, of which 4,068-8,715 were defined as beads. The data for each metal channel had been transformed using the formula ArcSinh(data)/c, in which c = 2 for CyTOF Helios data, and furthermore, each metal channel was normalized to values between 0 and 1 for the SVM training, to ensure maximal comparability between different samples. Consequently, new data to be classified using the developed SVM model should be transformed and normalized before \"gating\" - this is of course incorporated in the developed script. In order to evaluate the performance, a single-layer cross-validation setup was used, because a preliminary run on a smaller subset using a “out-of-the-box” SVM with a radial kernel, turned out to work satisfactory (mean accuracy of 99.997 %, with a mean precision of 99.920 %, and a mean recall of 99.971 %). The training was carried out using a leave-one-out method, in which six data sets was used for training and one data set was used for testing in each round. This should allow for an unbiased performance measure. Based on the obtained results the model was deemed acceptable, and all data sets were used to train a final model that can be used for future bead-normalization tasks - the developed R script requires this [final model](https://github.com/biosurf/CyTOF/blob/master/Bead_SVM_model.Rdata) to run. Because the seven training samples for the SVM were all from the CyTOF Helios platform, and they all used EQ beads with the five bead isotopes,  <sup>140</sup>Ce, <sup>151</sup>Eu, <sup>153</sup>Eu, <sup>165</sup>Ho, and <sup>175</sup>Lu,  the developed method in R only works for data obtained using the EQ beads on a Helios instrument.  However, it could potentially easily be extended to handle other data types - it merely requires some training data to develop the proper SVM for gating the given data set type. 

## Data transformations {transformations}

### Dealing with \"randomized\" values
When an FCS file is exported by the Helios, non-zero values are randomized negatively and uniformly (]x-1;x]). This means that a count of, for example, 9 will be evenly distributed between 8 and 9 for each channel, for each event. This is mostly done for historical reasons, as visualizing count data from the CyTOF produce different plots than intensity data (from flow cytometers). Randomization is done (by default) during conversion of IMD to FCS by the Fluidigm software. Randomized counts can be converted back to the original value by rounding every decimal up to the nearest whole number.

```r
# Check if counts are randomized (expression matrix should only contain integers)
is.wholenumber <- function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
table(is.wholenumber(exprs[,c(pregating_channels, lineage_channels)]))

# You may revert back to original counts (only applicable to measured channels - i.e. exclude time, event length, etc.)
exprs <- cbind(ceiling(exprs[,c(pregating_channels, lineage_channels)]), exprs[,instrument_channels])
```

For multidimensional analysis this is definitely recommendable not to add unnecessary noise to the data, but for the purpose of the 2D visualizations we are doing for pre-gating, we will leave the randomized counts for now.

### ArcSinh transformation
Commonly, mass cytometry ion counts will be ArcSinh transformed - this transformation will retain linearity in the low end of the count spectrum, but it resembles a log transformation in the high end. If counts are divided by a co-factor before the transformation, the range of ion counts for which linearity is retained may be adjusted. For CyTOF data, a co-factor of 5 is typically used. Transformations are done primarily for visualization purposes and co-factors are empirically determined. In some cases, adjusting co-factors slightly may improve visualizations.

Continuing from the above code snippet for loading an FCS, the data may be ArcSinh-transformed as follows:

```r
library(MASS)
library(RColorBrewer)
k <- 11; my.cols <- rev(brewer.pal(k, \"RdYlBu\"))

# Set co-factor
cofac <- 5

# Make arcsinh transformed expression matrix (with the exception of time and event_length, which should remain linear)
exprs_trans <- cbind(asinh(exprs[,c(pregating_channels, lineage_channels)]/cofac), exprs[,instrument_channels])

# Plot two-marker example of transformation effect
plot(exprs[,c(\"CD8\", \"CD4\")], pch=\".\", col=\"grey\", main=\"CD8 vs CD4\")
z <- kde2d(exprs[,\"CD8\"], exprs[,\"CD4\"], n=50)
contour(z, drawlabels=FALSE, nlevels=k, col=my.cols, add=TRUE)

plot(exprs_trans[,c(\"CD8\", \"CD4\")], pch=\".\", col=\"grey\", main=\"CD8 vs CD4 (transformed counts)\")
z <- kde2d(exprs_trans[,\"CD8\"], exprs_trans[,\"CD4\"], n=50)
contour(z, drawlabels=FALSE, nlevels=k, col=my.cols, add=TRUE)
```

![Raw ion counts vs arcsinh transformed counts](https://i.imgur.com/OmhBhh8.png)

Both the classic Logicle transformation and ArcSinh works by compressing values in the upper end of the spectrum and enhancing the resolution on the lower end:

![Logicle vs arcsinh transformation](https://i.imgur.com/t2XTC1P.png)

When plotting the variation for each marker before and after transformation, the difference is quite clear:

![The effect of transformation on data distribution](https://i.imgur.com/oWAJwoG.png)

## Pre-gating
Pre-gating has the purpose to filter the data to consist only of live, intact, single cells. Traditionally, this is carried out in four steps, carried out for each sample. There are number of ways one can semi or fully automate this process (using unsupervised or supervised machine learning for instance), but for clarity we will perform \"old school\" pre-gating below - sped up by pre-gating all samples in one go (insofar as samples are comparable to a degree that enables this). In the following sections, we will work on all the samples as a single object, so first we reload the data into a data.frame.

```r
# For the next step, set working directory to the normalized samples
setwd(\"~/cytof_primer/fcs_files/normed/\")

# Read in your normalized files and concatenate in a data frame (in this example we subset each matrix to 10,000 random events)
fcs_files <- list.files(pattern='.fcs$', full=TRUE, ignore.case = TRUE)
exprs_set <- data.frame()
sample <- c()
for(i in fcs_files) {
  fcs <- read.FCS(filename=i, transformation=FALSE) 
  exprs <- fcs@exprs
  markers <- gsub(pattern = \".*_\", replacement = \"\", x = as.vector(fcs@parameters@data$desc))
  colnames(exprs)[which(!is.na(markers))] <- markers[which(!is.na(markers))]
  # exprs <- cbind(floor(exprs[,!colnames(exprs) %in% instrument_channels]), exprs[,colnames(exprs) %in% instrument_channels])
  exprs_set <- rbind(exprs_set, exprs[sample(nrow(exprs), 10000),])
  sample <- append(sample, rep(i, 10000))
}
exprs_set$sample <- sample
instrument_channels <- append(instrument_channels, \"sample\")

# Make arcsinh transformed expression matrix (excluding channels that should remain linear - e.g. time, event length, etc.)
cofac <- 5 # For CyTOF data, the co-factor is set to 5
exprs_set_trans <-cbind(asinh(exprs_set[,c(pregating_channels, lineage_channels)]/cofac), exprs_set[,instrument_channels])
```

### Batch correction
Insofar as all samples are run on the same instrument, with the same panel, by the same operator, and bead normalized together, it should be possible to avoid pre-gating all your samples one at the time, and rather doing it in one go. You may check that the distributions of bead, DNA, and live/dead measurements are somewhat similar:

```r
library(scales)
library(RColorBrewer)

cols <- brewer.pal(5,'Set1')
par(mfrow=c(1,5))

for(c in 1:length(pregating_channels)) {
  plot(1, type = \"n\", xlim = c(0, max(exprs_set_trans[,pregating_channels[c]])), ylim = c(1, length(fcs_files) + 2), axes = FALSE, xlab = \"\", ylab = \"\", main=pregating_channels[c], cex.main=3)
  for(s in 1:length(fcs_files)){
    dens <- density(exprs_set_trans[exprs_set_trans$sample==fcs_files[s],pregating_channels[c]])
    dens$y = dens$y+(length(fcs_files)-s+1)
    par(bg=NA)
    lines(dens)
    polygon(dens, col=alpha(cols[c],0.4), border = NA)
    abline(h =(length(fcs_files)-s+1), lwd = 0.5)
  }
}
```

<img src=\"https://i.imgur.com/rRo1Ycg.png\" alt=\"Visualization of the manual pre-gating strategy\" style=\"width: 800px;\"/>

As can be seen all five pre-gating channels are largely comparable in all samples, and batch correction is not necesarry for pre-gating.

In case your data doesn't look quite as nice (these samples were run on the same instrument, by the same operator, during the course of a single day), you can correct for batch effect channel-by-channel using a range based approach (basically a linear alignment of densities) or a warping normalization that enables non-linear adjustments to individual peaks in the data (frequently referred to as landmarks).

First, let's construct an example:

```r
# Create two toy batches of bimodal densities (the cydar packages only takes lists of lists as input)
batches <- list()
x <- list()
ex <- matrix(c(rnorm(500,2,1), rnorm(500,25,2)), ncol=1)
colnames(ex) <- \"CDx\"
x[[\"sample_Y\"]] <- ex
batches[[\"Batch1\"]] <- x
ex <- matrix(c(rnorm(500,2.1,1.1), rnorm(500,15,2)), ncol=1)
colnames(ex) <- \"CDx\"
x[[\"sample_Y\"]] <- ex
batches[[\"Batch2\"]] <- x

# Plot the marker distributions
plot(density(batches$Batch1$sample_Y), main=\"uncorrected samples\", ylim=c(0,0.09))
points(density(batches$Batch2$sample_Y), type=\"l\", col=\"red\")
```
![Uncorrected samples](https://i.imgur.com/3SdFPxL.png)

The distributions are clearly unaligned and we will need to correct for this before we can analyze them together:

```r
# Run the normalization
library(cydar)
corrected <- normalizeBatch(batches, batch.comp = NULL, mode=\"warp\")

# Plot the results
plot(density(corrected$Batch1$sample_Y), main=\"batch corrected samples\")
points(density(corrected$Batch2$sample_Y), type=\"l\", col=\"red\")
```

![Batch corrected data](https://i.imgur.com/NrlRQJV.png)

Voila.

Channel-by-channel correction should be performed with care. A common source of noise is the stability (or lack thereof) of the antibody cocktail. In practice, this means that in one sample, a given channel can be virtually noise-free, whereas in another, noise can be introduced into that very channel - even if the same antibody cocktail is used. When warping such two channels to be comparable without a priori knowledge about what is noise and what is signal, one is basically making the noise comparable by \"contaminating\" the noise free sample.

Tools for system-wide batch correction are available. For example, the [distribution-matching residual networks](https://academic.oup.com/bioinformatics/article-lookup/doi/10.1093/bioinformatics/btx196) approach. However, the code for this tool is not yet available in an implementation-ready form. Python scripts are found [here](https://github.com/ushaham/BatchEffectRemoval), but issues like the example data being hard coded as the input data in the main script, prevents easy implementation of this otherwise interesting method.

If none of this does help on your data (this is obviously an oversimplified example), one solution is to analyze your samples individually and then compare the results. Batch correcting mass cytometry data is definitely non-trivial, and a method for modeling and removing system-wide as well as channel-specific noise has yet to see the light of day.

### Gating for cells (beads vs. DNA)

The first step is to gate out beads, cell/bead dobulets, and debris. This is done by generating a biaxial plot with a DNA channel (e.g. <sup>191</sup>Ir) on one axis and a bead-only isotope (<sup>140</sup>Ce) on the other. A single bead should be DNA-negative and <sup>140</sup>Ce-positive, and cells should be DNA-positive and <sup>140</sup>Ce-negative. Double negatives are considered to be debris and double positives are commonly doublets. Below is a code snippet for conducting this step after initializing as described [above](#fcs).

```r
# Load necessary packages
library(MASS)
library(RColorBrewer)

# Make color palette using color brewer
k <- 11; my.cols <- rev(brewer.pal(k, \"RdYlBu\"))

# Gate for cells (beads vs. DNA)
sub <- exprs_set_trans[exprs_set_trans$sample==fcs_files[4],c(\"Bead\", \"DNA1\")]
z <- kde2d(x=sub[,1], y=sub[,2], n=50, h=max(bandwidth.nrd(sub[,1]), bandwidth.nrd(sub[,2])))

# Generating a plot for gating visualization
plot(sub, pch=\".\", cex=0.1, col=\"gray\", xlab=colnames(sub)[1], ylab=colnames(sub)[2], xlim=c(0,max(sub[,1])), ylim=c(0,max(sub[,2])))
contour(z, drawlabels=FALSE, nlevels=k, col=my.cols, add=TRUE)

# Set gate boundaries - the values should be manually adjusted
left <- 0; right <- 3; lower <- 6; upper <- 9
rect(left,lower,right,upper,border=\"red\")
cells <- exprs_set_trans[exprs_set_trans[,\"Bead\"] < right,]; cells <- cells[cells[,\"DNA1\"] > lower & cells[,\"DNA1\"] < upper,]
paste(\"cells: \", round((nrow(cells)/nrow(exprs_set_trans))*100, digits=2), \"%\", sep=\"\")
```

![Gating for cell](https://i.imgur.com/SHUUXb7.png)

### Gating for intact cells (DNA1 vs DNA2)

The second step is to gate for intact cells - usually by generation a bixaial plot with the two DNA channels (<sup>191</sup>Ir and <sup>193</sup>Ir) and gating for events, which express both at a balanced level. If events express only little DNA it is likely debris, but if DNA expression is too high, they are likely cell doublets.  

```r
# Gate for intact cells (DNA1 vs DNA2)
sub <- exprs_set_trans[,c(\"DNA1\", \"DNA2\")]
z <- kde2d(sub[,1], sub[,2], n=50)

# Generating a plot for gating visualization
plot(sub, pch=\".\", cex=0.1, col=\"gray\", xlab=colnames(sub)[1], ylab=colnames(sub)[2], xlim=c(0,max(sub[,1])), ylim=c(0,max(sub[,2])))
contour(z, drawlabels=FALSE, nlevels=k, col=my.cols, add=TRUE)

# Set gate boundaries - the values should be manually adjusted
left <- 6.3; right <- 8.2; lower <- 6.8; upper <- 8.85
rect(left,lower,right,upper,border=\"red\")
intact <- cells[cells[,\"DNA1\"] > left & cells[,\"DNA1\"] < right,]; intact <- intact[intact[,\"DNA2\"] > lower & intact[,\"DNA2\"] < upper,]
paste(\"intact cells: \", round((nrow(intact)/nrow(cells))*100, digits=2), \"%\", sep=\"\")
```

![Gating for intact cells](https://i.imgur.com/rpi3Lh2.png)

### Gating for singlets (event length vs DNA)

The third step is to gate out doublets more specifically. This can be done by biaxially plotting event length against a DNA channel and gating for the events which have a length within the range of most events. 

```r
# Gate for singlets (event length vs. DNA)
sub <- intact[,c(\"Event_length\", \"DNA1\")]
z <- kde2d(sub[,1], sub[,2], n=50)

# Generating a plot for gating visualization
plot(sub, pch=\".\", cex=0.1, col=\"gray\", xlab=colnames(sub)[1], ylab=colnames(sub)[2], xlim=c(0,max(sub[,1])), ylim=c(0,max(sub[,2])))
contour(z, drawlabels=FALSE, nlevels=k, col=my.cols, add=TRUE)

# Set gate boundaries - the values should be manually adjusted
left <- 11; bottom <- min(sub[,2]); right <- 21; upper <- max(sub[,2])
rect(left,bottom,right,upper,border=\"red\", lwd=3) # Draw cells gate (format: ll x,y; ur x,y)
singlets <- intact[intact[,\"Event_length\"] > left & intact[,\"Event_length\"] < right,]
paste(\"Intact singlets: \", round((nrow(singlets)/nrow(intact))*100, digits=2), \"%\", sep=\"\")
```

![Gating for singlets](https://i.imgur.com/32Irz1E.png)

### Gating for live cells (live/dead stain vs DNA)

The final step is to remove dead cells. This is typically carried out by using a viability stain. This staining takes place before ligation of antibody-probes. Because dead cells have disrupted membranes, the stain can enter them and form bonds with intracellular molecules. The gating itself is carried out by biaxially plotting the viability stain and a DNA channel and gating out cells with a high amount of staining.

```r
# Gate for live
sub <- singlets[,c(\"Dead\", \"DNA1\")]
z <- kde2d(sub[,1], sub[,2], n=50)

# Generating a plot for gating visualization
plot(sub, pch=\".\", cex=0.1, col=\"gray\", xlab=colnames(sub)[1], ylab=colnames(sub)[2], xlim=c(0,max(sub[,1])), ylim=c(0,max(sub[,2])))
contour(z, drawlabels=FALSE, nlevels=k, col=my.cols, add=TRUE)

# Set gate boundaries - the values should be manually adjusted
left <- 0; bottom <- min(sub[,2]); right <- 5; upper <- max(sub[,2])
rect(left,bottom,right,upper,border=\"red\", lwd=3)
live <- singlets[singlets[,\"Dead\"] < right,]
paste(\"Live intact singlets: \", round((nrow(live)/nrow(singlets))*100, digits=2), \"%\", sep=\"\")
```

![Gating for live cells](https://i.imgur.com/UyfMgo9.png)

Finally, you can print the recovery percentage for each sample and save the live intact singlets to a new FCS file if you need to.

```r
for (i in fcs_files) {
  print(paste(\"Total recovery for \", i, \": \", round((nrow(live[live$sample==i,])/nrow(exprs_set_trans[exprs_set_trans$sample==i,]))*100, digits=2), \"%\", sep=\"\"))
}

# Save FCS containing live intact singlets
ff2 <- flowFrame(xt_live_intact_singlets, ff@parameters, ff@description)
suppressWarnings(write.FCS(ff2, filename = paste(\"./\",  file, \"live_intact_singlets\", sep=\"\"), what=\"numeric\", delimiter = \"\\\\\"))
```

More automated options for pre-gating can be conceived. One option is to train a supervised model, such as a support vector machine, on a sample for which manual gating has already been carried out. However, in this case it is also necessary to normalize and batch correct the data for alignment of the distributions of the pre-gating channels.

## Compensation
Compensation is a method for correcting signal overlap, or \"spillover\", between the different channels used in cytomtetry experiments. While being an established method in flow cytometry, a recent study ([Chevrier et al., 2018](http://dx.doi.org/10.1016/j.cels.2018.02.010)) highlight that mass cytometry experiments are also affected by signal spillover.  This leads to noisy expression matrices, and as a consequence, compensation must be applied. 

To perform compensation, you need to directly quantify the overlap between isotopes using beads (or cells) stained with a single isotope. Using these single-stained beads it is possible to estimate a spillover matrix from the populations identified as belonging to each isotope, and then one can apply the inverse of the matrix to compensate the data for CyTOF runs through multiplication.

The [CATALYST tool](http://bioconductor.org/packages/release/bioc/html/CATALYST.html) offers an implementation of a compensation method, which views spillover as linear (traditional approach) and uses non-negative linear least squares to avoid yielding negative expression values. Additionally, their vignette is quite extensive and helpful.

But how can you tell if your data needs compensation? In reality this may be hard, but one approach could be to use a biaxial plot to look for unexpected correlations between channels in your dataset. E.g. you would *usually* not expect a correlation between a barcoding channel and a surface marker, but you may expect a correlation between two maturity markers or two activation markers. So if you see something like the leftmost plot below (which shows a barcoding vs. a marker channel), you have a strong indication that something is wrong. Fortunately, it can be corrected using CATALYST to yield the rightmost plot. For this dataset (which is one of our own), none of the single-stained beads were actually stained with <sup>110</sup>Pd, and consequently any signal detected in this channel must be spillover.

![Compensation example. Left: Uncompensated data with a large spillover from the Cd114 channel to the Pd110 channel. Right: Compensated data.](https://i.imgur.com/a6FzOTC.png)

## Debarcoding
A GUI implementation of the single cell debarcoder may be installed from [here](https://github.com/ParkerICI/premessa) or [here](http://bioconductor.org/packages/release/bioc/html/CATALYST.html), but the CATALYST implementation may also be used without the GUI. However, it is still advisable to adjust the barcode separation cut-offs manually, and for this purpose it is necessary to plot the data. The original debarcoding paper was published by [Zunder et al.  (2013)](http://dx.doi.org/10.1038/nprot.2015.020), and the basic principle is that you use combinations of palladium isotopes to label individual samples, which you can then pool and run together on the CyTOF machine to avoid technical variation. To separate the different samples, one must identify events for which the difference in the signal between the present and absent palladium channels is clear. 

# Data analysis

## Dimensionality reduction {dimred}
### Principal component analysis {pca}
The most commonly used algorithm for dimensionality reduction in the biological sciences is principal component analysis (PCA). For mass cytometry data, a PCA will often capture 40-50% of the variance on the first 2-3 PCs, but since the distance between events is linear, data existing on a nonlinear manifold will be misrepresented [(Chester & Maecker 2015)](http://www.jimmunol.org/content/195/3/773.long). Whether this is an issue with CyTOF data or not depends heavily on the source of data. For example, as cells in the hematopoietic system develop in a hierarchical structure, the transition between some cells will result in a continuum rather than distinct clusters, which may not be entirely captured by PCA. 

```r
pca <- prcomp(live[live$sample==fcs_files[1],lineage_channels], scale. = TRUE)
plot(pca$x[,1:2], pch=21, bg=alpha(\"slategray4\",0.6), col=\"grey\")
```

![2D PCA](https://i.imgur.com/Dld6ETL.png)

### t-SNE {tsne}
The t-Distributed Stochastic Neighbor Embedding (t-SNE) dimensionality reduction algorithm  is a popular tool for dimensionality reduction of cytometry data (van der Maaten and Hinton, 2008). The distance between data points are represented by a t-distribution, meaning that multidimensional distances are preserved to a greater degree than PCA. However, there are a number of features of the algorithm that can lead to misinterpretation by the unaware user. For example, t-SNE (intentionally) does not preserve distances nor density, and it only preserves nearest-neighbors if reasonable hyperparameters are selected. This means that the sizes of the clusters are not always indicative of the variability within the cluster, and similarly, the distance between two clusters is not always proportional to how different they really are. In this regard, the algorithm is quite sensitive to the user making an informed choice of the perplexity and epsilon hyperparameters to reasonably represent the underlying structure of the data (See Martin Wattenberg et al.'s excellent blog post on [how to use t-SNE efficiently](http://distill.pub/2016/misread-tsne/).). Another feature that may be considered a disadvantage to some is that t-SNE depends on a random start and is non-deterministic even on the same data unless the same seed and iteration limit is used for each run. Additionally, removing or adding even a few data points from the input set will affect the layout of the remaining events, and consequently it is not directly possible to add samples to an existing t-SNE plot. Lastly, t-SNE does not allow for identical events, which, in the case of immune profiling where one would expect at least some identical cells in each cluster, means discarding or scrambling data. Dimensionality reduction definitely has a place in mass cytometry analysis pipelines, but for these reasons, it should be limited to exploratory and/or post-analysis visualizations. t-SNE is implemented in a number of languages including R, Python, C++, etc., and as a plug-in to FlowJo X. The MATLAB implementation of t-SNE often used for mass cytometry data in GUI pipelines is referred to as viSNE ([Amir et al., 2013](https://doi.org/10.1038/nbt.2594)).

Before running t-SNE, it is necessary to remove identical events (if any) from the sample (duplicate rows).

```r
table(duplicated(live[live$sample==fcs_files[1],lineage_channels]))
# No duplicates here, but if so, they can be removed:
live <- live[-which(duplicated(live[live$sample==fcs_files[1],lineage_channels]))]
```

```r
library(Rtsne)
set.seed(42)
tsne <- Rtsne(live[live$sample==fcs_files[1],lineage_channels])
plot(tsne$Y[,1:2], pch=21, bg=alpha(\"slategray4\",0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5)
```

![2D t-SNE](https://i.imgur.com/20LPhRO.png)

Even before clustering, it is possible to get some sense of the cell composition in a sample by selectively coloring cells by marker expression on the t-SNE plot:

```r
par(mfrow=c(2,2))
for(i in c(\"CD4\", \"CD8\", \"CD19\", \"CD56\")) {
  cols_ramp <- colorRamp(c(\"slategray4\", \"red\"))
  marker_exprs_scaled <- (live[live$sample==fcs_files[1],i] - min(live[live$sample==fcs_files[1],i]))/diff(range(live[live$sample==fcs_files[1],i]))
  cols <- rgb(cols_ramp(marker_exprs_scaled), maxColorValue = 256)
  plot(tsne$Y[,1:2], pch=21, bg=alpha(cols,0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5, main=i)
}
```
![Cells highlighted by marker expression](https://i.imgur.com/6KXyzP4.png)


### UMAP
Uniform Manifold Approximation and Projection (UMAP) is a newer addition to the family of CyTOF-applicable dimensionality reduction methods ([Becht et al., 2018](http://dx.doi.org/10.1038/nbt.4314)). It works in a fashion that is more similar to t-SNE than PCA, which means that it also views each cell as a member of a neighborhood of similar cells. However, it has several advantages over t-SNE. The first one is speed. For a small dataset there may not be a significant difference, bu you will surely notice it for a million cells. Furthermore, UMAP preserves global distances in the data a lot better than t-SNE. Recall that distances have no meaning in a t-SNE plot - you can not say anything about *how* different clusters are with t-SNE and distances between clusters tend to be fairly constant. In UMAP plots, distances once again have meaning, although they are not linear and directly interpretable as for PCA. 

UMAP, like t-SNE also requires setting a seed for each run to make it reproducible. UMAP is implemented in several languages including R and Python.

```r
library(umap)
set.seed(42)
umap <- umap(live[live$sample==fcs_files[1],lineage_channels], n_neighbors = 15, min_dist = 0.2, metric = 'euclidean', method = 'naive')
plot(umap$layout[,1:2], col = 'grey', bg = scales::alpha(\"slategray4\",0.6), pch = 21, xlab = 'UMAP1', ylab = 'UMAP2')
```

![2D UMAP](https://i.imgur.com/TTxTrT4.jpg)


Again, it is possible to get a pretty good insight into cell composition in a sample by selectively coloring cells by marker expression on the UMAP plot - you will also notice how this is similar to the patterns seen with t-SNE:

```r
par(mfrow=c(2,2))
for(i in c(\"CD4\", \"CD8\", \"CD19\", \"CD56\")) {
  cols_ramp <- colorRamp(c(\"slategray4\", \"red\"))
  marker_exprs_scaled <- (live[live$sample==fcs_files[1],i] - min(live[live$sample==fcs_files[1],i]))/diff(range(live[live$sample==fcs_files[1],i]))
  cols <- rgb(cols_ramp(marker_exprs_scaled), maxColorValue = 256)
  plot(umap$layout[,1:2], pch=21, bg=alpha(cols,0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5, main=i)
}
```
![Cells highlighted by marker expression](https://i.imgur.com/irRiEXw.jpg)


## Cell subset detection (clustering) {clustering}
Deconvoluting a cell mixture may be a goal in itself, and certainly a necessity for meaningful comparison of samples or cell populations whether transversal or longitudinal. The traditional approach relies on manual gating on biaxial plots, but as the number of features are increased, the manual strategy becomes increasingly laborious. A number of methods are therefore seeking to automate or semi-automate the process - not only in the interest of speed, but unsupervised methods may also reveal cell populations overlooked when following standard gating strategies.

Automated strategies are usually based on some form of clustering. Since the hematopoietic continuum is a cellular hierarchy, the obvious first choice is simply hierarchical clustering. However, this method is by some considered suboptimal, usually ascribed to the need to manually select the number of clusters based on a distance cutoff in the resulting dendrogram. This forces the user to guess the number of populations in the sample: selecting too many will over-separate the data into meaningless small clusters; selecting too few will agglomerate smaller, but potentially interesting clusters into larger ones. Additionally, with a computational complexity of O(n) and a typical yield of ~200.000 cells per sample, this can be a time consuming algorithm to run on CyTOF data. However, multiple tools still utilize hierarchical clustering in their algorithms. SPADE (Qiu et al. 2011), for example, overcomes the computational challenges and the risk of missing rare populations by performing density dependent down-sampling before hierarchical clustering.

Phenograph (automatically decides the optimal number of clusters) and FlowSOM (you need to provide an informed guess of the number of clusters) were recently shown to be the best performing algorithms in a [comparison of the main algorithms by Weber and Robinson 2016](http://onlinelibrary.wiley.com/doi/10.1002/cyto.a.23030/abstract). It is of course worth mentioning that there are many other methods available (eg. [ACCENSE](http://www.cellaccense.com/) and [clusterX](http://bioconductor.org/packages/release/bioc/vignettes/cytofkit/inst/doc/cytofkit_example.html)). We will also briefly touch upon a few tools such as e.g. X-shift (Samusik et al. 2016), or force-directed layout-based methods, e.g. SCAFFoLD (Spitzer et al. 2015), which currently do not have R command based interfaces, as well as cover tools with integrated clustering (e.g. [SPADE](https://github.com/nolanlab/spade/wiki) and [citrus](https://github.com/nolanlab/citrus)) in greater depth in later sections.

### Phenograph
Phenograph is an algorithm which directly assigns single cells to a particular cluster while taking the all measured dimensions into account. Phenograph employs a k-nearest neighbor graph (k-NNG), in which each cell is a node that is connected to its nearest neighbors by edges, to cluster cells into phenotypically similar groups - cellular populations. Clusters consist of nodes with high inter-connectivity. Phenograph is implemented in the R package \"cytofkit\".

Phenograph also requires removal of duplicates (see [t-SNE section](#tsne) above).

```r
library(cytofkit)
clusters_pg <- cytof_cluster(xdata = live[live$sample==fcs_files[1],lineage_channels], method = \"Rphenograph\")
```

```r
# Visualize results on PCA
getPalette = colorRampPalette(brewer.pal(9, \"Set1\"))
cols <- getPalette(max(clusters_pg))
plot(pca$x[,1:2], pch=21, bg=alpha(col=cols[clusters_pg],0.6), col=\"grey\")
```

![2D PCA with phenograph clusters](https://i.imgur.com/9LRWd3s.png)

The 2D PCA visualization doesn't provide good visual separation of clusters. Adding an extra PC adds a significant amount of visual resolution to the clustering. Here is a toy example from a manually gated sample of PBMC from a healthy donor (toggle clusters by clicking on the names in the legend):

![{\"type\":\"data\", \"dataset\":\"59afbf1da6b06402ace2194d\", \"subset\":\"null\"}](3D--PCA--with--Phenograph--clusters)

```r
# Visualize results on t-SNE plot
getPalette = colorRampPalette(brewer.pal(9, \"Set1\"))
cols <- getPalette(max(clusters_pg))
plot(tsne$Y[,1:2], pch=21, bg=alpha(col=cols[clusters_pg],0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5)
```

![2D t-SNE with phenograph clusters](https://i.imgur.com/sbEQxYt.png)

Below is an interactive implementation of Phenograph clustering + t-SNE on a sample of PBMC from a healthy donor (toggle clusters by clicking on the names in the legend):

![{\"type\":\"data\", \"dataset\":\"59afc3b6a6b06402ace2194e\", \"subset\":\"null\"}](2D--t-SNE--with--Phenograph--clusters)

If you want to see how multiple samples compare with clustering and t-SNE, one approach is to pool events from multiple samples, cluster them together, and plot them individually on a t-SNE canvas (recall that t-SNE will produce potentially vastly different layouts if samples are run separately). Below is an example with four samples:

```r
# Sample 5000 random events from each sample
sub <- NULL
for(i in 1:4) {
  temp <- live[live$sample==fcs_files[i],]
  sub <- rbind(sub, temp[sample(nrow(temp), 5000, replace=FALSE),])
}
# Check for duplicated events (remove if applicable)
table(duplicated(sub[,lineage_channels]))
sub <- sub[-which(duplicated(sub[,lineage_channels]))]
# Cluster using phenograph
clusters_pg <- cytof_cluster(xdata = sub[,lineage_channels], method = \"Rphenograph\")
# Run t-SNE
set.seed(42)
tsne <- Rtsne(sub[,lineage_channels])
# Plot each sample on t-SNE canvas consisting of all events
getPalette = colorRampPalette(brewer.pal(9, \"Set1\"))
cols <- getPalette(max(clusters_pg))
par(mfrow=c(2,2))
for(i in 1:4) {
  plot(tsne$Y[,1:2], pch=19, col=\"slategray4\", xlab=\"\", ylab=\"\", lwd=0.5, main=paste(\"sample\", i))
  points(tsne$Y[sub$sample==unique(sub$sample)[i],1:2], pch=21, bg=alpha(col=cols[clusters_pg[sub$sample==unique(sub$sample)[i]]],0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5)
}
```
![Sample comparison using t-SNE](https://i.imgur.com/u693Qgl.png)

### FlowSOM clustering
FlowSOM is a method for clustering and visualization of flow and mass cytometry data. FlowSOM uses two levels of clustering to visualize how the intensity of cell type markers varies across the populations, and the amount of clusters used is quite high to ensure a visualization of even small subpopulations.

A standalone [R package for FlowSOM](https://bioconductor.org/packages/release/bioc/html/FlowSOM.html) enables clustering, SOM, and MST visualizations. The package is built to run on FCS files rather than expression matrices, so here we will use the FlowSOM clustering implementation from the cytofkit package.

```r
library(cytofkit)
clusters_fs <- cytof_cluster(xdata = live[live$sample==fcs_files[1],lineage_channels], method = \"FlowSOM\", FlowSOM_k=25)
```

```r
# Visualize results on t-SNE plot
getPalette = colorRampPalette(brewer.pal(9, \"Set1\"))
cols <- getPalette(max(clusters_fs))
plot(tsne$Y[,1:2], pch=21, bg=alpha(col=cols[clusters_fs],0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5)
```

![2D t-SNE with FlowSOM cluster](https://i.imgur.com/QBZCQ7M.png)

### VorteX
VorteX is a clustering tool, which is implemented in Java and available as a graphical tool. VorteX includes different clustering algorithms incl. X-shift (non-parametric, density-based), hierarchical clustering, Mean-shift and K-medoids. In VorteX it is also easy to visualize the results or clusterings using different plot types. 

### SCAFFoLD
SCAFFoLD (Single-Cell Analysis by Fixed Force- and Landmark-Directed) is, as the name indicates, a tool based on the use of force-directed graphs. First, cells are clustered, and then the clusters are spatialized in the plane. This means that similar clusters are put closer to each other than dissimilar ones. This results in a map. Furthermore, it is possible to highlight landmark populations that have been manually gated (working as references). As a result it is possible to compare a new sample to an old, to look for global structure changes. Samples can be clustered both individually and together.

To use SCAFFoLD, you need a C++ compiler and once that is ready you can run the program as follows:

```r
# Loading required packages
require(devtools) || install.packages(\"devtools\")
source(\"http://bioconductor.org/biocLite.R\")
biocLite(\"flowCore\")
library(devtools)
install_github(\"nolanlab/scaffold\")
library(scaffold)

# Running SCAFFoLD (launching a GUI), please note that your current working directory should contain your files of interest before launching the GUI
scaffold.run()
```
A complete use guide for the GUI is found [here](https://github.com/nolanlab/scaffold).

## Visualizing marker expression in different clusters
Once cells have been clustered, examining the expression profiles of the cells in each cluster can be used to provide clues about the type of cells constituting the clusters. This can be done in various ways:

### Simple heatmap
The most basic way to visually show the marker profiles of clusters is with a simple heatmap of median marker expressions. This of course has the drawback of ignoring the variance of the marker expression in each cluster, but offers does offer some insights into the composition of each cluster.

```r
library(miscTools)
sub_matrix <- live[live$sample==fcs_files[1],lineage_channels]
cluster_matrix <- NULL
for(i in 1:max(clusters)) {
  cluster_matrix <- rbind(cluster_matrix, colMedians(sub_matrix[clusters==i,]))
}
library(gplots)
cols = colorRampPalette(c(brewer.pal(9, \"Set1\")[2], brewer.pal(9, \"Set1\")[1]))
par(mar = c(2,2,2,2))
heatmap.2(t(cluster_matrix), col=cols, trace=\"none\", density.info = \"none\", sepcolor = \"white\", sepwidth = c(0.001, 0.001), colsep=c(1:ncol(t(cluster_matrix))), rowsep=c(1:nrow(t(cluster_matrix))), xlab=\"cluster\", ylab=\"channel\", scale=\"row\")
```

![Simple heatmap of marker expression in each phenograph cluster](https://i.imgur.com/fcAk8cO.png)

### Radviz
Radviz is a visualization scheme that utilizes so-called dimensional anchors. Each anchor (in this case, each marker) is distributed on the circumference of a circle, and ordered in a way that markers whose expression correlate, are located closer to each other. Each event is then projected into the circular and located closer to markers that best describe them. The authors use the following descriptive analogy to explain the algorithm: \"In Radviz, each dimension in the dataset is represented by a dimensional anchor, and each dimensional anchor is distributed evenly on a unit circle. Each line in the data set corresponds to a point in the projection, that is linked to every dimensional anchor by a spring. Each spring’s stiffness corresponds to the value for that particular thing in that particular dimension. The position of the point is defined as the point in the 2D space where the spring’s tension is minimum.\" [Read more here](https://cran.r-project.org/web/packages/Radviz/vignettes/single_cell_projections.html).

```r
library(Radviz)
cell.S <- make.S(colnames(sub_matrix))
cell.sim <- cosine(as.matrix(sub_matrix))
optim.cell <- do.optim(cell.S,cell.sim,iter=100,n=1000)
cell.S <- make.S(tail(optim.cell$best,1)[[1]])
cell.rv <- do.radviz(as.matrix(sub_matrix),cell.S)
layout(matrix(c(1,1,1,2), nrow=1,ncol=4))
plot(cell.rv, point.shape=19, point.color=alpha(cols[clusters], 0.6))
plot.new()
legend(\"center\", legend=paste(\"cluster\", 1:max(clusters)), col=cols, cex=1, pch=16, bty='n')
```

![Radviz plot](https://i.imgur.com/Sm84OCA.png)

Clusters can be visualized more clearly in a \"bubble plot\" version of Radviz. In this plot, events are collapsed to the coordinates of their respective cluster centroid, where the size of the \"bubble\" corresponds to the size of the cluster.

```r
pop.rv <- do.radviz(cluster_matrix,cell.S)
size <- table(clusters)
layout(matrix(c(1,1,1,2), nrow=1,ncol=4))
bubbleRadviz(pop.rv, bubble.color=alpha(cols[1:nrow(cluster_matrix)],0.8), bubble.size=log(size[1:nrow(cluster_matrix)]), scale=0.2, decreasing=TRUE)
plot.new()
legend(\"center\", legend=paste(\"cluster\", 1:max(clusters)), col=cols, cex=1, pch=16, bty='n')
```

![Radviz bubble plot](https://i.imgur.com/ry5Fffs.png)

## Analysis of differential abundance of cell populations and proteins {daanalysis}
Once subpopulations are clustered in each sample, the next step will often be to elucidate associations between cluster frequencies and/or protein expression and a given condition or time. These exercises closely resemble differential expression analyses used in transcriptomics for decades, and the bioinformatics toolbox contains multiple tools for basic significance tests and linear models. In addition, the GUI tools Citrus and Statistical Scaffold were developed for this purpose. 

Citrus (cluster identification, characterization, and regression) (Bruggner et al. 2014) works by combining hierarchical clustering of events in all samples aggregated into one. Then, descriptive metrics for each cluster are calculated, including percentage of cells assigned to each cluster, and the median expression of lineage markers in each cluster. These data are then used in regularized classification models to elucidate factors differing across conditions.

The Statistical Scaffold method (Spitzer et al. 2017) works in a similar way. First, populations of interest are separated by manual gating in a representative sample. These populations will serve as landmark nodes on a scaffold map, which serves as a template for mapping events in the remaining samples using the cosine similarity between the vectors of median marker values of each cluster. Lastly, the Significance Across Microarrays permutation test (Tusher et al. 2001) is applied to test for differences in population frequencies across conditions.

One major shortcoming of existing tools is the inability to handle more complex experimental setups, such as longitudinal studies, or studies with multiple factors and covariates. Generalized linear models (GLM) for differential expression analysis, popularized for transcriptomic analyses by tools such as limma (Ritchie et al. 2015) for microarray data and DEseq2 (Love et al. 2014) or EdgeR (Robinson et al. 2010) for RNA sequencing data, accepts model matrices with co-variates for complex experimental designs. Recently, Lun and colleagues leveraged GLMs from the EdgeR software specifically for mass cytometry data and showed these models outperform Citrus on legacy data (Lun et al. 2017).

Lastly, it is important to consider that the immune system consists of multiple functional cell populations, which are coordinated in a complex interplay in response to various conditions. It is therefore sometimes more informative to examine population frequencies as dependent variables by examining correlations or ratios between frequencies (Bailur et al. 2017). Additionally, natural variations in the immune system are likely to mask the difference conferred by time or conditions when looking at a single variable, even if analyzing a large number of samples. Much like transcriptomics analyses, the immune system does not consist of independent variables, and neither the abundance of protein markers on individual cells nor the frequencies of individual cell populations can be assumed independent from the remaining variables.

### Analysis of differential abundance of cells in clusters {dacells}
The cell counts in each cluster is the easiest to compare, as this roughly follows a negative binomial distribution and can be flexibly modeled using a generalized linear model (GLM) as implemented in, for example, the edgeR package for RNA-seq transcriptomics data. In this example, we will use the data generated by Bodenmiller et al. and identify clusters with a differential abundance of cells between conditions.

First, we import the data and create a dataframe with all the samples:
```r
# Import data
library(flowCore)
setwd(\"~/cytof_primer/case_control/fcs_files/\")
fcs_files <- list.files(pattern='.fcs$', full=TRUE, ignore.case = TRUE)
exprs_set <- data.frame()
sample <- c()
for(i in fcs_files) {
  fcs <- read.FCS(filename=i, transformation=FALSE) 
  exprs <- fcs@exprs
  colnames(exprs) <- gsub(pattern = \".*_\", replacement = \"\", x = as.vector(fcs@parameters@data$desc))
  exprs <- asinh(exprs/5)
  exprs_set <- rbind(exprs_set, exprs)
  sample <- append(sample, rep(i, nrow(exprs)))
}
exprs_set$sample <- sample

# Set channels
pregating_channels <- c(\"DNA-1\", \"DNA-2\")
lineage_channels <- c(\"CD45\", \"CD4\", \"CD20\", \"CD33\", \"CD123\", \"CD14\", \"IgM\", \"HLA-DR\", \"CD7\", \"CD3\")
functional_channels <- c(\"pNFkB\", \"pp38\", \"pStat5\", \"pAkt\", \"pStat1\", \"pSHP2\", \"pZap70\", \"pStat3\", \"pSlp76\", \"pBtk\", \"pPlcg2\", \"pErk\", \"pLat\", \"pS6\")
instrument_channels <- c(\"length\", \"Time\", \"sample\", \"BC1\", \"BC2\", \"BC3\", \"BC4\", \"BC5\", \"BC6\", \"BC7\")
```

In the interest of speed, we here down sample to 1000 random events from each sample. Remember to normalize to the total number of events in each sample if the full samples are used.  We then cluster using the cytofkit implementation of phenograph and create a table with cell counts in each cluster for each sample.

```R
# Sample 1000 random events form each sample
sub <- NULL
for(i in unique(exprs_set$sample)) {
  temp <- exprs_set[exprs_set$sample==i,]
  sub <- rbind(sub, temp[sample(nrow(temp), 1000, replace=FALSE),lineage_channels])
}
sample <- rep(unique(exprs_set$sample), each=1000)

# cluster
library(cytofkit)
clusters_pg <- cytof_cluster(xdata = sub, method = \"Rphenograph\")

# make frequency table
cell_counts <- matrix(nrow=max(clusters_pg), ncol=0)
for (i in unique(sample)) {
  sample_count <- table(clusters_pg[sample==i])
  column <- unname(sample_count[match(1:nrow(cell_counts), names(sample_count))])
  column[is.na(names(sample_count[match(1:nrow(cell_counts), names(sample_count))]))] <- 0
  cell_counts <- cbind(cell_counts, column)
}
conditions <- rep(1, 16)
conditions[grep(\"BCR-XL\", fcs_files)] <- \"BCR-XL\"
conditions[grep(\"Reference\", fcs_files)] <- \"Reference\"
colnames(cell_counts) <- conditions
```

Lastly, we evaluate differential abundance in each cluster using a NB-GLM from the edgeR package:

```R
# calculate differential abundance
library(edgeR)

dge <- DGEList(cell_counts, lib.size=rep(1000,16))
design <- model.matrix(~factor(conditions))
y <- estimateDisp(dge, design)
fit <- glmQLFit(y, design, robust=TRUE)
res <- glmQLFTest(fit, coef=2)
```

We can now visualize the log2 fold change in clusters with a significant differential abundance between the two conditions:

```r
# visualize on t-SNE
library(Rtsne)
library(RColorBrewer)
library(scales)

set.seed(42)
tsne <- Rtsne(sub)

# par(mfrow=c(1,2))
layout(matrix(c(1,1,1,2,2,2,3), nrow=1,ncol=7))

getPalette = colorRampPalette(brewer.pal(9, \"Set1\"))
cols <- getPalette(max(clusters_pg))
plot(tsne$Y, pch=21, bg=alpha(col=cols[clusters_pg],0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5, main=\"Phenograph clusters\")

log2fc <- res$table$logFC
log2fc[res$table$PValue>0.05] <- 0
colpal <- colorRampPalette(c('red', \"grey\", 'blue'))
cols <- colpal(100)[as.numeric(cut(log2fc,breaks = 100))]
plot(tsne$Y, pch=21, bg=alpha(col=cols[clusters_pg],0.6), col=\"grey\", xlab=\"\", ylab=\"\", lwd=0.5, main=\"colored by log2FC\")

legend_image <- as.raster(matrix(colpal(20), ncol=1))
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = 'log2FC')
text(x=1.5, y = seq(0,1,l=3), labels = c(round(min(log2fc), digits = 2),0,round(max(log2fc),digits=2)))
rasterImage(legend_image, 0, 0, 1, 1)
```

![Visualizing differential abundance on t-SNE plots](https://i.imgur.com/JRscapE.png)

We can also visually show the cell abundance difference between clusters using the approach in [section 3.2](#clustering):

![Visualizing cell abundance on t-SNE canvas](https://i.imgur.com/zwkBhok.png)

#### cydar
The cydar tool works in much the same way as above - clustering followed by statistical testing for differential abundance of cells in each cluster.  In this method, the clustering is done by creating hyperspherical clusters. This partitioning is similar to that of k-means clustering, but here a constant distance measure (the radius) is used to define the hyperspheres rather than dividing the events into Voronoi cells based on the nearest mean. This means that rather than getting a (somewhat) interpretable cluster structure (where each cluster can be labeled as a canonical cell population), hyperspherical partitioning is somewhat abstract and not directly interpretable. Another feature of the hypersphere partitioning is allowing multi-membership (which one can argue makes more biological sense than strictly allowing cells to belong to one cluster), but this again makes the partitioning harder to interpret in 2 or 3 dimensional space.  Although harder to directly interpret, choosing a k that is greater than \"reality\", is certainly better than selecting a k that is too small: \"under-clustering\" a highly heterogeneous cell mixture such as PBMC, will potentially result in comparing biologically irrelevant subsets. However, the trade-off of erring on the safe side is that in order for the cydar output to be biologically interpretable, some post-processing is necessary. The authors provide an excellent discussion of this in their [paper](https://www.nature.com/nmeth/journal/v14/n7/full/nmeth.4295.html) and in their [R package vignette](https://bioconductor.org/packages/release/bioc/vignettes/cydar/inst/doc/cydar.html)

Now for some code!

```r
library(cydar)
library(ncdfFlow)

# Sample 1000 random events form each sample - cydar takes data as a list of matrices
sub <- list()
for(i in unique(exprs_set$sample)) {
  temp <- exprs_set[exprs_set$sample==i,]
  sub[[i]] <- temp[sample(nrow(temp), 1000, replace=FALSE),lineage_channels]
}
conditions <- rep(1, 16)
conditions[grep(\"BCR-XL\", fcs_files)] <- \"BCR-XL\"
conditions[grep(\"Reference\", fcs_files)] <- \"Reference\"
sample.id <- rep(c(1:16), each=1000)

# Count the cells into hyperspheres with a radius equal to 0.5 times the square root of the number of markers
cd_all <- prepareCellData(sub)
cd_all <- countCells(cd_all, tol=0.5)

# Testing for significant differences in abundance
library(edgeR)
y <- DGEList(assay(cd_all), lib.size=cd_all$totals)
keep <- aveLogCPM(y) >= aveLogCPM(5, mean(cd_all$totals))
cd <- cd_all[keep,]
y <- y[keep,]
design <- model.matrix(~factor(conditions))
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust=TRUE)
res <- glmQLFTest(fit, coef=2)

# Controlling the spatial FDR
qvals <- spatialFDR(intensities(cd), res$table$PValue)
is.sig <- qvals <= 0.05
```

In this case we find that 253 out of 549 hyperspheres contain a significantly different number of cells between our two conditions.

```R
# Print the number of hypersphere with significantly different cell abundance between case and control
summary(is.sig)
   Mode   FALSE    TRUE 
logical     296     253 
```

### Analysis of differential expression of proteins between clusters {deprot}
The expression of lineage markers between different clusters will naturally differ, as differential expression is the very basis for all the clustering algorithms discussed here. However, it may be of interest to examine whether the expression of functional markers differs within a cluster that is considered to represent the same cell type in two different conditions.

Currently, the most widely utilized approach is to compare the median expression a given protein in each sample across conditions for a specific cluster. There are some potentially **serious caveats to this approach** which we will discuss a bit further down. But first, let's go through a simple example of this common approach:

```R
# Sample 1000 random events form each sample
sub <- NULL
for(i in unique(exprs_set$sample)) {
  temp <- exprs_set[exprs_set$sample==i,]
  sub <- rbind(sub, temp[sample(nrow(temp), 1000, replace=FALSE),c(lineage_channels, functional_channels)])
}
sample <- rep(unique(exprs_set$sample), each=1000)

# cluster
library(cytofkit)
clusters_pg <- cytof_cluster(xdata = sub[,lineage_channels], method = \"Rphenograph\")

# Make median expression table (samples x functional proteins) for each cluster
# - here we generate the table for cluster 1
library(miscTools)
sub_cluster <- sub[clusters_pg==1,functional_channels]
sample_cluster <- sample[clusters_pg==1]
exprs_cluster <- NULL
for(i in unique(sample_cluster)) {
  exprs_cluster <- cbind(exprs_cluster, colMedians(sub_cluster[sample_cluster==i,]))
}
colnames(exprs_cluster) <- unique(sample_cluster)
```

Again we are left with a simple expression matrix, to which you can apply your favorite statistics. Here we use a linear model:

```R
# Basic DE test using limma
library(limma)
conditions_test <- factor(gsub(\".*(Reference|BCR-XL).*\", \"\\\\1\", colnames(exprs_cluster)))
patient_test <- factor(gsub(\".*patient(.)_.*\", \"\\\\1\", colnames(exprs_cluster)))
design <- model.matrix(~patient_test+conditions_test)
fit <- lmFit(exprs_cluster, design)
fit <- eBayes(fit)
res <- topTable(fit, coef=\"conditions_testReference\", number=\"inf\", adjust.method=\"bonferroni\")
```

Which results in:
```
              logFC     AveExpr           t      P.Value    adj.P.Val         B
pNFkB   0.901599304  1.64626641  8.95197298 1.570931e-05 0.0002199304  3.567493
pAkt   -0.495415877  2.57505470 -4.62954456 1.553046e-03 0.0217426438 -1.285979
pSlp76  0.277175958  0.07675553  3.97151164 3.855769e-03 0.0539807621 -2.245577
pBtk    0.416567743  0.16310906  3.73853120 5.400805e-03 0.0756112746 -2.599032
pp38    0.492161765  0.17251180  3.27901472 1.072462e-02 0.1501446325 -3.313240
pErk   -0.245753542  0.32830765 -3.08944667 1.433815e-02 0.2007340740 -3.612798
pLat   -0.226744720  0.28252997 -2.72364712 2.534997e-02 0.3548995620 -4.194273
pS6    -0.187262388  0.06369062 -2.70666148 2.603589e-02 0.3645024835 -4.221272
pStat3 -0.152212475  0.08025186 -2.70645026 2.604454e-02 0.3646235574 -4.221607
pStat1 -0.341139355  1.00338611 -2.18346123 5.949445e-02 0.8329222973 -5.042568
pZap70 -0.066471291 -0.02515855 -2.13249427 6.447399e-02 0.9026358745 -5.120647
pPlcg2 -0.211360381  0.55087960 -2.07229530 7.088211e-02 0.9923495922 -5.212186
pStat5 -0.009597480 -0.06214086 -0.49439836 6.339071e-01 1.0000000000 -7.001390
pSHP2  -0.001402016 -0.06092106 -0.07812268 9.395902e-01 1.0000000000 -7.132165
```

So in cluster 1 we have two significantly differentially expressed proteins between the Reference and BCR-XL samples, based on the median expression of the protein.

The most glaring (potential) issue with using the median expression is that we assume homoscedasticity and ignore the variance of the expression within each sample. Another potential issue is that for the linear models, we assume that the expression values (and median values) follow a Gaussian distribution. As mentioned earlier, the arcsinh transformation is first and foremost a cosmetic operation for biaxial plots, and the raw counts (without the default randomization by the Fluidigm software) roughly follows a (somewhat zero-inflated) negative binomial distribution. As such, a more appropriate statistic may be adopted from common practices in single cell transcriptomics analyses, but the error model has to be adapted: for example, dropout events are not an issue in mass cytometry, but the isotope counts are subject to stochastic noise and antibody binding introduces some fairly systematic noise (as discussed in our manuscript) that should be modeled appropriately. Lastly, we measure far fewer features in mass cytometry, but vastly more observations compared with single cell transcriptomics. Until such a model is formulated, linear modeling of median marker expression remains the state-of-the-art.

#### Citrus
One of the tools that utilizes this method is Citrus (cluster identification, characterization, and regression). The Citrus algorithm works by first doing an optional down-sampling to a user-specified number of events from each sample followed by hierarchical clustering of the pooled cells. When clusters are defined, Citrus utilizes algorithms from the SAM (statistical analysis of microarrays) package to calculate 1) differential abundance of cells in clusters across the defined conditions, 2) differential median protein expression in each cluster across the defined conditions, and 3) trains a lasso regularized logistic regression and nearest shrunken centroids method to identify a subset of cluster features that best stratifies the condition from the control samples. Citrus is primarily implemented as a GUI, but an [R package](https://github.com/nolanlab/citrus) allow for command-based execution. In either case, Citrus takes only FCS files. The method is described in the [2014 paper by Bruggner et al.](http://www.pnas.org/content/111/26/E2770.long). 

## Cell type assignment {celltypes}
In order to finally draw biological conclusions from the clustering and differential population frequency and/or protein expression analyses, differential population frequency analyses, or differential marker expression analyses, it is necessary to assign a cell type to each cluster. For domain experts, this may be as simple as comparatively surveying the marker expression in each cluster, for example by generating clusters vs. markers heatmaps or aided by tools such as Marker Enrichment Modelling (MEM) (Diggins et al. 2017), which can be used to label clusters with a simpler human readable marker enrichment profile. Other tools such as flowCL (Courtot et al. 2015), ACDC (Lee et al. 2017) or the LDA-approach by [Abdelaal et al. (2019)](https://doi.org/10.1002/cyto.a.23738) enables automated assignment of labels to clusters, but flowCL requires the user to make decisions about when a marker is expressed or not and uses the phenotype label to assign the most likely label, and ACDC requires users to define population labels with a markers x populations binary expression matrix. 

The lack of a fully automated cell type assignment workflow is most likely due to the fact that assigning canonical populations is trivial for domain experts, while rare populations may be subject to disagreement, and novel populations not yet named are likely to be present. However, for the computationally inclined, the Python implementation of ACDC can be used to perform a label estimate on clustered data.


### ACDC
Automated Cell-type Discovery and Classiffcation (ACDC) takes a cell type-marker table, in which each cell type is related to a marker profile. The table can contain values 1 (present), -1 (absent), 0/NA (do not consider) for each marker and cell type combination. This table can be completely customized to suit the measured markers
of a study and include the cell types one wishes to study. The values should be based on the biological knowledge of marker expression of different cell types (e.g. all T cells express CD3). Then each cell is classified resulting in a clustering in which each cluster is labeled as a specific cell type. This method is consequently biased by the cell-type marker table applied, but it may be useful in certain situations. ACDC is available for Python and tutorials for running the program can be found [here](https://github.com/howchihlee/ACDC_tutorial/tree/master/notebooks). We have also made [our own IPython Notebook-tutorial](https://github.com/biosurf/CyTOF/blob/master/ACDC_BioSurf.ipynb) for running ACDC.

Three different cell-type marker tables can be accessed in our Git repository: The [AML table](https://github.com/biosurf/CyTOF/blob/master/AML_table.csv), the [BMMC table](https://github.com/biosurf/CyTOF/blob/master/BMMC_table.csv), and a [table defined by Michael D. Leipold](https://github.com/biosurf/CyTOF/blob/master/Leipold_table.csv). The two first tables were derived from [Levine et al.](https://www.cytobank.org/nolanlab/reports/Levine2015.html) and processed into the csv format by the original ACDC-developers.

### Marker Enrichment Modeling
The Marker Enrichment Modeling (MEM) tools describes cellular subsets by the features that are enriched for each population using a weighted marker expression profile. MEM describes the characteristics of different clusters in the context of the other cells in the sample - e.g. certain surface markers specifically enriched in the given cluster.

The output is a weighted marker expression profile of each cluster, which can be translated into a \"human readable\" label for each cluster. In this example, we use the clusters from phenograph and create a list of human readable labels for each cluster.

```r
# Calculate enrichment scores
mem <- MEM(cbind(live[live$sample==unique(live$sample)[1],lineage_channels], cluster<-clusters_pg))

# This creates a table of enrichment scores for each marker in each cluster. Round these scores to get a label as presented in their paper
mem <- round(mem[[5]][[1]])

# Adapt label format from numeric to \"--\", \"-\", \"+\". \"++\" (this is necessary for the \"flowcl\" package below)
mem <- mem[order(as.numeric(rownames(mem))),]
threshold <- median(abs(as.vector(mem)))
labels <- list()
for(i in 1:nrow(mem)) {
  lab <- mem[i,abs(mem[i,])>0]
  lab[lab < -threshold] <- \"--\"
  lab[lab < 0] <- \"-\"
  lab[lab > threshold] <- \"++\"
  lab[lab > 0] <- \"+\"
  lab <- paste(names(lab), lab, sep=\"\")
  labels[[rownames(mem)[i]]] <- paste(lab, collapse=\"\")
}
```

This creates the following cluster labels:

```
[1] CD19+CD4++CD11c++CD16+CD3++CD38++CD27++CD14+CXCR5+CCR7+CD20+CD127++CD33++CD28++CD123+HLADR++CD25+
[2] CD19-CD4++CD8-CD11c++CD16+CD3-CD38++CD27-CXCR5+CCR7-CD45RA-CD127-CD33++CD28++CD123+HLADR++CD25++
[3] CD4++CD8-IgD-CD11c-CD16-CD3++CD38-CD27++CD14-CXCR5++CCR7++CD45RA-CD20-CD127++CD33+CD28++CD161+CD123-CD56-HLADR-
[4] CD19-CD4-IgD-CD11c-CD16+CD3-CD38+CD27-CD14-CXCR5-CCR7-CD45RA+CD20-CD127-CD33-CD28-CD161+CD123+CD56+HLADR-CD25-
[5] CD4-CD11c-CD16-CD3++CD38-CD27++CD14-CXCR5-CCR7-CD45RA-CD20-CD127++CD33+CD28++CD161+CD123+HLADR-CD25-
[6] CD57+CD19-CD4++CD8-CD11c++CD16+CD3-CD38++CD27-CD14++CXCR5+CCR7-CD45RA-CD127-CD33++CD28-CD161+CD56+HLADR++CD25+
[7] CD4++CD8-CD11c-CD16-CD3++CD38-CD27++CD14-CXCR5+CCR7++CD45RA+CD20-CD127+CD33+CD28++CD123+CD56-HLADR-CD25+
[8] CD57+CD4++CD8-CD11c-CD16-CD3++CD38+CD27++CD14+CXCR5-CCR7++CD45RA+CD20-CD127++CD33+CD28++CD161+CD123-CD56-HLADR-CD25-
[9] CD4++CD8-IgD-CD11c-CD16-CD3++CD38-CD27-CD14-CXCR5-CCR7-CD45RA-CD20-CD127++CD33+CD28++CD123+CD56-HLADR-CD25+
[10] CD19-CD4-CD8-IgD-CD11c-CD16-CD3++CD27++CD14-CXCR5+CCR7+CD45RA++CD20+CD127+CD33-CD28++CD123+CD56-HLADR-CD25-
[11] CD4++CD8-IgD-CD11c-CD16-CD3++CD38-CD27++CD14-CXCR5-CCR7+CD45RA-CD20-CD127++CD33+CD28++CD123-CD56-HLADR-
[12] CD19++CD4+CD8+IgD++CD11c++CD16-CD3++CD38+CD27++CD14-CXCR5++CCR7++CD45RA++CD20++CD127++CD33-CD28++CD56+HLADR+CD25++
[13] CD19-CD4-CD8-IgD-CD11c++CD16-CD3-CD38-CD27-CXCR5-CCR7-CD45RA-CD20-CD127-CD33+CD28-CD123+CD56-HLADR++CD25+
[14] CD19++CD4-CD8-IgD++CD11c-CD16-CD3-CD38+CD27-CD14-CXCR5++CCR7+CD45RA++CD20++CD127-CD33-CD28-CD161+CD56+HLADR++CD25+
[15] CD4++CD8-IgD-CD11c-CD16-CD3++CD38-CD27++CD14-CXCR5-CCR7+CD45RA-CD20-CD127++CD33+CD28++CD161+CD123+CD56-HLADR-CD25+
[16] CD19-CD4++CD8-IgD-CD11c-CD16-CD3-CD38+CD27-CD14-CXCR5-CCR7+CD45RA++CD20+CD127-CD33-CD28-CD123++CD56+HLADR++CD25+
[17] CD57+CD4+CD8+CD11c+CD16++CD3++CD38+CD27++CCR7+CD45RA++CD127+CD33+CD28++CD161+CD123+CD56++HLADR-
[18] CD19++CD4-CD8-CD11c-CD16-CD3-CD38-CD27++CD14-CXCR5++CCR7+CD45RA++CD20++CD127-CD33-CD28-CD123+CD56-HLADR++CD25+
[19] CD4++CD8-IgD-CD11c-CD16-CD3++CD38-CD27+CD14-CXCR5-CCR7-CD45RA-CD20-CD127+CD33+CD28++CD123+CD56-HLADR++CD25+
[20] CD19-CD4-CD8-IgD-CD11c+CD16++CD3-CD38+CD27+CD14-CXCR5-CCR7-CD45RA++CD127-CD33-CD28-CD161+CD123+CD56++HLADR-CD25-
[21] CD4-CD8++CD11c-CD16-CD3++CD38-CD27++CXCR5-CCR7++CD45RA++CD20+CD127++CD33-CD28++CD123-CD56-HLADR-CD25-
[22] CD57++CD19-CD4-CD8+IgD-CD11c+CD16++CD3-CD38+CD27-CD14-CXCR5-CCR7-CD45RA++CD127-CD33-CD28-CD161+CD123-CD56++HLADR-CD25-
[23] CD4++CD8+CD11c++CD16++CD3-CD38-CD27-CXCR5+CCR7-CD45RA+CD20+CD127-CD33+CD28-CD161+CD123+CD56+HLADR++CD25+
[24] CD57++CD4-CD8++CD11c-CD3++CD38-CD27-CD14-CXCR5-CCR7+CD45RA-CD20-CD127-CD33-CD28-CD123-CD56-HLADR-CD25-
[25] CD4-CD8++CD11c-CD16-CD3++CD38-CD27++CD14-CXCR5-CCR7+CD45RA-CD20-CD127+CD33-CD28++CD123-CD56-HLADR-CD25-
[26] CD19-CD4-CD8+IgD-CD11c+CD16++CD3-CD38+CD27-CD14-CXCR5-CCR7-CD45RA++CD127-CD33-CD28-CD161+CD123+CD56++HLADR-CD25-
```

These labels alone will not be meaningful to non-domain experts, and in order to assign a cell name to each cluster, one will need to query an ontology database.

### flowCL
flowCL assigns a phenotype to a cell based on its expressed markers - it matches against the [Cell Ontology (CL)](http://cellontology.org). An example query could be \"CD16-CD14+CD33+\", but it is also possible to use -- and ++ for the marker levels to be more specific regarding the level of a marker.

We can run flowCL directly on the list created using MEM:

```r
library(\"flowCL\")
res <- flowCL(MarkerList = labels, ExpMrkrLst = as.list(lineage_channels), VisualSkip = TRUE)
```

**NOTE: flowCL is currently times out when pinging the Cell Ontology database. The authors have been contacted and are working on fixing the problem**

## Cellular hierarchies {hierarchies}
Cells of the immune system exist in a hierarchy of different developmental and activation states. Estimating and visualizing the proportion of cells in a complex mixture belonging to different states can be useful to identify aberrations in cellular differentiation between different conditions. The spanning-tree progression analysis of density-normalized events (SPADE) (Qiu et al. 2011) is one of the first tools to address this problem for mass cytometry data. At the core of SPADE is a minimum spanning-tree algorithm, which is applied to clusters of cells to derive possible hierarchies within the data. Events are clustered using hierarchical clustering after data is downsampled in a density-dependent manner. This serves to speed up the clustering, but also ensures equal representation of rare and dense populations. The clusters in the resulting minimum spanning-tree must then be manually labelled, but this is aided by plots highlighted by marker intensity for each sample. Early versions of SPADE relied on stochastic downsampling and stochastic minimum spanning-trees, which produced different run-to-run results, but recent updates of the software produces deterministic results (Qiu 2017). SPADE is implemented in C++, but exists with an R wrapper.

Wanderlust is a graph-based approach to uncovering cell development trajectories. It works by first constructing a k-nearest neighbor graph, connecting each cell to its k nearest neighbors based on Euclidean distance. Then, the shortest path between an initiator node (a user selected root cell) and every other cell in the network is used to estimate the development trajectory of each event (Bendall et al. 2014). Wanderlust is implemented in Matlab.

### FlowSOM
Self-organizing maps (SOM) and minimum spanning tree (MST) visualizations can be generated using the kohonen package for the SOM, and the igraph package for the MST. The flowSOM implementations of these do contain some extra plotting options. If you want visualizations exactly like those presented in the [paper](http://onlinelibrary.wiley.com/doi/10.1002/cyto.a.22625/full), you may try their [R package](https://bioconductor.org/packages/release/bioc/html/FlowSOM.html). Note that it only takes FCS files as input, but individual functions can be edited if an explicit need for these visualizations exists.

```r
# Calculate and visualize self organizing map with the parameters used by FlowSOM
library(kohonen)
som <- som(as.matrix(live[live$sample==fcs_files[1],lineage_channels]), grid=somgrid(xdim = 10, ydim = 10), dist.fcts=\"euclidean\")

# Calculate codebook clusters
library(ConsensusClusterPlus)
nclust <- 15
cclust <- ConsensusClusterPlus(t(som$codes[[1]]), maxK = nclust, reps = 100, pItem = 0.9, pFeature = 1, title = tempdir(), plot = \"pdf\", verbose = FALSE, clusterAlg = \"hc\", distance = \"euclidean\", seed = NULL)
codebook_clusters <- cclust[[nclust]]$consensusClass
codebook_list <- list()
for(i in 1:max(codebook_clusters)) {
  codebook_list[[i]] <- names(codebook_clusters[codebook_clusters==i])
}

# Create minimum spanning tree from codebook distance matrix
library(igraph)
graph  <- graph.adjacency(as.matrix(dist(som$codes[[1]])), weighted = TRUE)
mst <- mst(graph)

# Plot flowSOM-like MST output
layout <- layout.kamada.kawai(as.undirected(mst))
marker_palette = colorRampPalette(brewer.pal(9, \"Set1\"))
cluster_palette = colorRampPalette(brewer.pal(8, \"Set2\"))
marker_cols <- marker_palette(length(lineage_channels))
cluster_cols <- cluster_palette(max(codebook_clusters))
medians <- t(apply(som$codes[[1]], 1, function(x) x/sum(x)))
plot(as.undirected(mst), vertex.shape=\"star\", vertex.label = NA, vertex.size = rep(10, length(codebook_clusters)), vertex.data = medians, vertex.cP = marker_palette(ncol(medians)), vertex.scale = TRUE, layout = layout, edge.lty = 1, mark.groups = codebook_list, mark.col = alpha(cluster_cols,0.4), mark.border = NA, mark.shape=1)
legend(x=1.2,y=1.1,legend=lineage_channels, col=marker_cols, pch=19, cex=0.7, bty=\"n\", y.intersp=0.8)
legend(x=-1.8,y=1.1,legend=paste(\"cluster\", 1:nclust), col=cluster_cols, pch=19, cex=0.7, bty=\"n\", y.intersp=0.8)
```

![MST with SOM codebook clustering](https://i.imgur.com/J9hQvVk.png)

Note that this visualization was developed for flow cytometry where fewer markers are measured. For higher-dimensionality data, such as from the CyTOF, it can be difficult to discern the expression of the individual markers, so selecting a subset representing major parent populations could be useful.



# Analysis tool overview

| Tool                  | Purpose                                                                            | Reference                                                                                                                                   |
|-----------------------|------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| CytoRFD               | Cell distance measurement                                                          | [Pouyan et al. (2016)](https://doi.org/10.1109/EMBC.2016.7591260)                                                                           |
| ACDC                  | Cell type assignment                                                               | [Lee et al. (2017)](https://doi.org/10.1093/bioinformatics/btx054)                                                                          |
| CytoCompare           | Cell type assignment                                                               | [Platon et al. (2018)](https://doi.org/10.1016/j.ymeth.2017.09.005)                                                                         |
| DeepCyTOF             | Cell type assignment                                                               | [Li et al. (2017)](https://doi.org/10.1093/bioinformatics/btx448)                                                                           |
| CyTOF-Linear-Classifier                  | Cell type assignment                                  | [Abdelaal et al. (2019)](https://doi.org/10.1002/cyto.a.23738)                                                                          |
| HiPPO and PANDA       | Cell type assignment                                                               | [Pirrò et al. (2016)](https://doi.org/10.7287/peerj.preprints.2188v1)                                                                       |
| Mondrian              | Cell type assignment                                                               | [Ji et al. (2017)](https://arxiv.org/abs/1711.07673)                                                                                        |
| MP (Mondrian)         | Cell type assignment                                                               | [Ji et al. (2018)](https://doi.org/10.1101/414904)                                                                                          |
| xCell                 | Cell type assignment                                                               | [Aran et al. (2017)](https://doi.org/10.1101/114165)                                                                                        |
| cytometree                 | Cell type assignment                                                               | [Commenges et al. (2018)](https://doi.org/10.1002/cyto.a.23601)                                                                                        |
| SCAFFoLD              | Cell type assignment, cellular trajectory mapping                                  | [Spitzer et al. (2015)](https://doi.org/10.1126/science.1259425)                                                                            |
| Statistical SCAFFoLD  | Cell type assignment, cellular trajectory mapping, differential abundance analysis | [Spitzer et al. (2017)](https://doi.org/10.1016/j.cell.2016.12.022)                                                                         |
| DREMI/DREVI           | Cellular trajectory detection                                                      | [Krishnaswamy et al. (2014)](https://doi.org/10.1126/science.1250689)                                                                       |
| Wanderlust            | Cellular trajectory detection                                                      | [Bendall et al. (2014)](https://doi.org/10.1016/j.cell.2014.04.005)                                                                         |
| ECLAIR                | Cellular trajectory detection                                                      | [Giecold et al. (2016)](https://doi.org/10.1093/nar/gkw452)                                                                                 |
| TreeTop               | Cellular trajectory detection                                                      | [Macnair et al. (2017)](https://doi.org/10.1101/200923)                                                                                     |
| Wishbone              | Cellular trajectory detection                                                      | [Setty et al. (2016)](https://doi.org/10.1038/nbt.3569)                                                                                     |
| PP-SLIDE              | Cellular trajectory detection (prediction of precursor cells)                      | [Cavrois et al. (2017)](https://doi.org/10.1016/j.celrep.2017.06.087)                                                                       |
| ACCENSE               | Clustering                                                                         | [Shekhar et al. (2014)](https://doi.org/10.1073/pnas.1321405111)                                                                            |
| DensVM                | Clustering                                                                         | [Becher et al. (2014)](https://doi.org/10.1038/ni.3006)                                                                                     |
| FlowSOM               | Clustering                                                                         | [Van Gassen et al. (2015)](https://doi.org/10.1002/cyto.a.22625)                                                                            |
| PhenoGraph            | Clustering                                                                         | [Levine et al. (2015)](https://doi.org/10.1016/j.cell.2015.05.047)                                                                          |
| SPADE                 | Clustering                                                                         | [Qui et al. (2011)](https://doi.org/10.1038/nbt.1991)                                                                                       |
| X-Shift               | Clustering                                                                         | [Samusik et al. (2016)](https://doi.org/10.1038/nmeth.3863)                                                                                 |
| ClusterX              | Clustering                                                                         | [Chen et al. (2016)](https://doi.org/10.1371/journal.pcbi.1005112)                                                                          |
| FlowGrid              | Clustering                                                                         | [Ye & Ho (2018)](https://doi.org/10.1101/394189)                                                                                            |
| Rclusterpp            | Clustering                                                                         | [Nolan Lab GitHub](https://github.com/nolanlab/Rclusterpp)                                                                                  |
| CCAST                 | Clustering                                                                         | [Anhang et al. (2014)](https://doi.org/10.1371/journal.pcbi.1003664)                                                                        |
| Convex clustering     | Clustering                                                                         | [Radchenko & Mukherjee (2017)](https://doi.org/10.1111/rssb.12226)                                                                          |
| CytoSPADE             | Clustering                                                                         | [Linderman et al. (2012)](https://doi.org/10.1093/bioinformatics/bts425)                                                                    |
| densityCUT            | Clustering                                                                         | [Ding et al. (2016)](https://doi.org/10.1093/bioinformatics/btw227)                                                                         |
| DEPECHE               | Clustering                                                                         | [Theorell et al. (2018)](https://doi.org/10.1101/396135)                                                                                    |
| flowMEANS             | Clustering                                                                         | [Aghaeepour et al. (2011)](https://doi.org/10.1002/cyto.a.21007)                                                                            |
| immunoCLUST           | Clustering                                                                         | [Sörensen et al. (2015)](https://doi.org/10.1002/cyto.a.22626)                                                                              |
| OpenCyto              | Clustering                                                                         | [Finak et al. (2014)](https://doi.org/10.1371/journal.pcbi.1003806)                                                                         |
| PAC-MAN               | Clustering                                                                         | [Pezzotti et al. (2017)](https://doi.org/10.1371/journal.pcbi.1005875)                                                                      |
| SOPHE                 | Clustering                                                                         | [Zaunders et al. (2015)](https://doi.org/10.1002/cyto.a.22704)                                                                              |
| Citrus                | Clustering, differential abundance analysis                                        | [Bruggner et al. (2014)](https://doi.org/10.1073/pnas.1408792111)                                                                           |
| Cydar                 | Clustering, differential abundance analysis                                        | [Lun et al. (2017)](https://doi.org/10.1038/nmeth.4295)                                                                                     |
| diffcyt               | Clustering, differential abundance analysis                                        | [Weber et al. (2018)](https://doi.org/10.1101/349738)                                                                                       |
| RchyOptimyx           | Clustering, simulating manual gating                                               | [Aghaeepour et al. (2012)](https://doi.org/10.1002/cyto.a.22209) and [O'Neill et al. (2014)](https://doi.org/10.1093/bioinformatics/btt770) |
| MAGAN                 | Comparison of different types of measurements                                      | [Amodio & Krishnaswamy (2018)](https://arxiv.org/abs/1803.00385)                                                                            |
| MetaCYTO              | Comparison of different types of measurements                                      | [Hu et al. (2018)](https://doi.org/10.1016/j.celrep.2018.07.003)                                                                            |
| Sensitivity Analysis  | Covariance of markers                                                              | [G'Sell et al. (2013)](https://arxiv.org/abs/1308.2329)                                                                                     |
| Stochastic Bayes      | Covariance of markers                                                              | [Knowles (2015)](https://arxiv.org/abs/1509.01631)                                                                                          |
| CellCnn               | Detection of disease-associated cell subsets                                       | [Arvanti & Claassen (2017)](https://doi.org/10.1038/ncomms14825)                                                                            |
| t-SNE                 | Dimensionality reduction                                                           | [van der Maaten et al. (2008)](https://www.jmlr.org/papers/v9/vandermaaten08a.html)                                                         |
| PCA                   | Dimensionality reduction                                                           |                                                                                                                                             |
| A-tSNE                | Dimensionality reduction                                                           | [Li et al. (2017)](https://doi.org/10.1109/TVCG.2016.2570755)                                                                               |
| CytoBinning           | Dimensionality reduction                                                           | [Shen et al. (2018)](https://doi.org/10.1101/321893)                                                                                        |
| destiny               | Dimensionality reduction                                                           | [Angerer et al. (2015)](https://doi.org/10.1093/bioinformatics/btv715)                                                                      |
| Cluster‐to‐Gate       | Gating hierarchy generation                                                        | [Yang & Qui (2018)](https://doi.org/10.1002/cyto.a.23577)                                                                                   |
| Hypergate       | Gating hierarchy generation                                                        | [Becht et al. (2018)](https://doi.org/10.1093/bioinformatics/bty491)                                                                                   |
| CytoBackBone          | Improving marker selection                                                         | [Tchitchek Lab GitHub](https://github.com/tchitchek-lab/CytoBackBone)                                                                       |
| QFMatch               | Matching of cell clusters between samples                                          | [Orlova et al. (2018)](https://doi.org/10.1038/s41598-018-21444-4)                                                                          |
| Hierarchical Bayesian | Network modeling                                                                   | [Mitra et al. (2014)](https://doi.org/10.4137/CIN.S13984)                                                                                   |
| SCENERY               | Network modeling                                                                   | [Papoutsoglou et al. (2017)](https://doi.org/10.1093/nar/gkx448)                                                                            |
| CellCycleTRACER       | Normalization of cell-cycle and cell-volume effects                                | [Rapsomaniki et al. (2018)](https://doi.org/10.1038/s41467-018-03005-5)                                                                     |
| Batch-Free Encoding   | Removal of batch effects                                                           | [Shaham (2018)](https://doi.org/10.1101/380816)                                                                                             |
| SAUCIE                | Removal of batch effects, clustering, visualization                                | [Amodio et al. (2018)](https://doi.org/10.1101/237065)                                                                                      |
| GateFinder            | Simulating manual gating                                                           | [Aghaeepour et al. (2018)](https://doi.org/10.1093/bioinformatics/bty430)                                                                   |
| PHATE                 | Visualization                                                                      | [Moon et al. (2018)](https://doi.org/10.1101/120378)                                                                                        |
| Radviz                | Visualization                                                                      | [Abraham et al. (2016)](https://doi.org/10.1002/cyto.b.21499)                                                                               |
| Sconify               | Visualization                                                                      | [Burns et al. (2018)](https://doi.org/10.1101/337485)                                                                                       |
| Cytosplore            | Visualization                                                                      | [Höllt et al. (2016)](https://doi.org/10.1111/cgf.12893)                                                                                    |
| CyteGuide             | Visualization                                                                      | [Höllt et al. (2017)](https://doi.org/10.1109/TVCG.2017.2744318)                                                                            |
| NetworkPainter        | Visualization                                                                      | [Karr et al. (2015)](https://doi.org/10.1186/s12859-015-0602-4)                                                                             |
| SLIDE                 | Visualization                                                                      | [Sen et al. (2015)](https://doi.org/10.1016/j.ymeth.2015.07.008)                                                                            |


#### R session info {sessioninfo}
```r
R version 3.4.1 Patched (2017-08-31 r73172)
Platform: x86_64-apple-darwin15.6.0 (64-bit)
Running under: OS X El Capitan 10.11.6

Matrix products: default
BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] cydar_1.0.0                SummarizedExperiment_1.6.3 DelayedArray_0.2.7         matrixStats_0.52.2         Biobase_2.36.2            
 [6] GenomicRanges_1.28.4       GenomeInfoDb_1.12.2        IRanges_2.10.2             S4Vectors_0.14.3           BiocGenerics_0.22.0       
[11] BiocParallel_1.10.1        flowCore_1.42.2            BiocInstaller_1.26.0      

loaded via a namespace (and not attached):
 [1] pcaPP_1.9-72            Rcpp_0.12.12            DEoptimR_1.0-8          compiler_3.4.1          plyr_1.8.4             
 [6] XVector_0.16.0          bitops_1.0-6            viridis_0.4.0           tools_3.4.1             zlibbioc_1.22.0        
[11] digest_0.6.12           viridisLite_0.2.0       tibble_1.3.4            gtable_0.2.0            lattice_0.20-35        
[16] rlang_0.1.2             Matrix_1.2-11           graph_1.54.0            shiny_1.0.5             mvtnorm_1.0-6          
[21] gridExtra_2.2.1         GenomeInfoDbData_0.99.0 cluster_2.0.6           grid_3.4.1              robustbase_0.92-7      
[26] R6_2.2.2                rrcov_1.4-3             plotrix_3.6-6           ggplot2_2.2.1           corpcor_1.6.9          
[31] htmltools_0.3.6         scales_0.5.0            xtable_1.8-2            mime_0.5                colorspace_1.3-2       
[36] httpuv_1.3.5            lazyeval_0.2.0          RCurl_1.95-4.8          munsell_0.4.3
```