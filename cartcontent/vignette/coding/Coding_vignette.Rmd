---
title: "CAR-T Target Assessment Workflow: Computational Approaches"
author: "Giorgia Moranzoni"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    highlight: tango
    code_folding: show
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      cache = TRUE, fig.width = 12, fig.height = 8)
```

# Introduction

This vignette provides a comprehensive computational workflow for CAR-T target assessment, designed for bioinformaticians and computational biologists. All analyses are reproducible, scalable, and follow best practices for data provenance and quality control.

We demonstrate this workflow using **ERBB2** (HER2/neu) as an example target.

## Required Packages

```{r load_packages}
rm(list = ls())
library(tidyverse)
library(UCSCXenaTools)
library(biomaRt)
library(Biostrings)
library(patchwork)
library(scales)
library(msa)

# Set global options
options(timeout = 300)
theme_set(theme_light())
```

# Find Isoforms and Sequences

## Retrieve Isoforms from Ensembl via biomaRt

```{r get_isoforms}
# Connect to Ensembl
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")

# Retrieve all transcripts for target gene
get_gene_transcripts <- function(gene_symbol) {
  # Get all data first
  raw_data <- getBM(
    attributes = c("ensembl_gene_id", "ensembl_transcript_id", 
                   "transcript_biotype", "uniprotswissprot", "uniprotsptrembl",
                   "transcript_length", "transcript_start", "transcript_end"),
    filters = "hgnc_symbol",
    values = gene_symbol,
    mart = ensembl
  )
  
  # Process to get one row per transcript with all UniProt IDs
  raw_data %>%
    filter(transcript_biotype == "protein_coding") %>%
    # Group by transcript and collapse UniProt IDs
    group_by(ensembl_gene_id, ensembl_transcript_id, transcript_biotype,
             transcript_length, transcript_start, transcript_end) %>%
    summarise(
      uniprot_ids = paste(unique(c(uniprotswissprot, uniprotsptrembl)[
        c(uniprotswissprot, uniprotsptrembl) != ""]), collapse = ";"),
      .groups = "drop"
    ) 
  # %>%
  #   filter(uniprot_ids != "") %>%
  #   arrange(desc(transcript_length))
}

# Example: ERBB2
her2_transcripts <- get_gene_transcripts("ERBB2")
her2_transcripts
```

## Retrieve Protein Sequences

<!-- ```{r get_sequences} -->
<!-- # Get protein sequences from UniProt -->
<!-- get_protein_sequences <- function(uniprot_ids) { -->
<!--   sequences <- list() -->
<!--   for (id in unique(uniprot_ids)) { -->
<!--     url <- paste0("https://www.uniprot.org/uniprot/", id, ".fasta") -->
<!--     tryCatch({ -->
<!--       seq <- readAAStringSet(url) -->
<!--       sequences[[id]] <- seq -->
<!--     }, error = function(e) NULL) -->
<!--   } -->
<!--   return(sequences) -->
<!-- } -->

<!-- # Get ERBB2 isoform sequences -->
<!-- erbb2_sequences <- get_protein_sequences(erbb2_transcripts$uniprotswissprot) -->
<!-- ``` -->


```{r get_sequences}
# Get protein sequences from Ensembl using biomaRt
get_protein_sequences <- function(transcript_ids, mart) {
  # Query Ensembl for peptide sequences
  seqs <- getBM(
    attributes = c("ensembl_transcript_id", "peptide"),
    filters = "ensembl_transcript_id",
    values = transcript_ids,
    mart = mart
  )
  
  # Convert to AAStringSet
  sequences <- AAStringSet(seqs$peptide)
  names(sequences) <- seqs$ensembl_transcript_id
  
  # Remove empty sequences
  sequences <- sequences[width(sequences) > 0]
  
  return(sequences)
}

# Get ERBB2 isoform sequences
her2_sequences <- get_protein_sequences(
  transcript_ids = her2_transcripts$ensembl_transcript_id,
  mart = ensembl
)

# View sequence information
her2_sequences %>% view()
```
<!-- ## Check for Identical Sequences -->
<!-- ```{r check_duplicates} -->
<!-- # Function to identify duplicate sequences -->
<!-- find_duplicate_sequences <- function(sequences) { -->

<!--   # Convert to data frame with sequence strings -->
<!--   seq_df <- data.frame( -->
<!--     transcript_id = names(sequences), -->
<!--     sequence = as.character(sequences), -->
<!--     length = width(sequences) -->
<!--   ) -->

<!--   # Find duplicates -->
<!--   seq_df <- seq_df %>% -->
<!--     group_by(sequence) %>% -->
<!--     mutate( -->
<!--       n_duplicates = n(), -->
<!--       duplicate_group = cur_group_id() -->
<!--     ) %>% -->
<!--     ungroup() %>% -->
<!--     arrange(duplicate_group, transcript_id) -->

<!--   # Summary -->
<!--   cat("Total transcripts:", nrow(seq_df), "\n") -->
<!--   cat("Unique sequences:", length(unique(seq_df$sequence)), "\n") -->
<!--   cat("Duplicate groups:", sum(seq_df$n_duplicates > 1) /  -->
<!--         length(unique(seq_df$duplicate_group[seq_df$n_duplicates > 1])), "\n\n") -->

<!--   # Show duplicates -->
<!--   duplicates <- seq_df %>% -->
<!--     filter(n_duplicates > 1) %>% -->
<!--     dplyr::select(duplicate_group, transcript_id, length, n_duplicates) -->

<!--   if (nrow(duplicates) > 0) { -->
<!--     cat("Duplicate sequences found:\n") -->
<!--     print(duplicates, n = Inf) -->
<!--   } else { -->
<!--     cat("No duplicate sequences found.\n") -->
<!--   } -->

<!--   return(seq_df) -->
<!-- } -->

<!-- # Check ERBB2 sequences -->
<!-- erbb2_seq_check <- find_duplicate_sequences(erbb2_sequences) -->

<!-- # Optional: Show sequence length distribution -->
<!-- erbb2_seq_check %>% -->
<!--   ggplot(aes(x = length)) + -->
<!--   geom_histogram(binwidth = 50, fill = "steelblue", color = "white") + -->
<!--   labs( -->
<!--     title = "ERBB2 Isoform Sequence Lengths", -->
<!--     x = "Sequence length (amino acids)", -->
<!--     y = "Count" -->
<!--   ) + -->
<!--   theme_minimal() -->
<!-- ``` -->

<!-- This code will: -->
<!-- 1. Compare all sequences in `erbb2_sequences` -->
<!-- 2. Identify which transcripts have identical sequences -->
<!-- 3. Group them together and show how many duplicates exist -->
<!-- 4. Display a summary table of duplicate groups -->
<!-- 5. Create a histogram showing the distribution of sequence lengths -->

<!-- If there are duplicates, you'll see them grouped with their transcript IDs and lengths! -->




## Save Sequences for DeepLoc Analysis
```{r save_fasta}
# Write sequences to FASTA file
fasta_file <- "../../data/her2_isoforms.fasta"
writeXStringSet(her2_sequences, filepath = fasta_file)

cat("FASTA file saved to:", fasta_file, "\n")
cat("Number of sequences:", length(her2_sequences), "\n")
cat("\nUpload this file to DeepLoc 2.1 webserver:\n")
cat("https://services.healthtech.dtu.dk/services/DeepLoc-2.1/\n")
```

Run DeepLoc 2.1 webserver

## Visualize DeepLoc Results
```{r plot_deeploc_heatmap, fig.width=6}
# Read DeepLoc results
deeploc_file <- "../../results/HER2_analysis/HER2_deeploc21.csv"

plot_deeploc_heatmap <- function(deeploc_file, gene_name = "ERBB2", gene_display = "HER2") {
  
  # Read results
  results <- read_csv(deeploc_file, show_col_types = FALSE)
  
  # Select the subcellular localization probability columns
  localization_cols <- c("Cell membrane", "Cytoplasm", "Endoplasmic reticulum",
                         "Extracellular", "Golgi apparatus", "Lysosome/Vacuole",
                         "Mitochondrion", "Nucleus", "Peroxisome", "Plastid")
  
  # Prepare data for plotting
  plot_data <- results %>%
    dplyr::select(Protein_ID, all_of(localization_cols)) %>%
    pivot_longer(
      cols = -Protein_ID,
      names_to = "localization",
      values_to = "probability"
    )
  
  # Create heatmap
  ggplot(plot_data, aes(x = localization, y = Protein_ID, fill = probability)) +
    geom_tile(color = "white", linewidth = 0.5) +
    scale_fill_gradient2(
      low = "#4575b4",
      mid = "#ffffbf", 
      high = "#d73027",
      midpoint = 0.5,
      limits = c(0, 1),
      breaks = c(0.25, 0.50, 0.75),
      labels = c("0.25", "0.50", "0.75")
    ) +
    labs(
      title = paste0("Target: ", gene_display, " (", gene_name, ")"),
      x = NULL,
      y = NULL,
      fill = NULL
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 8),
      plot.title = element_text(size = 12, face = "bold"),
      legend.position = "top",
      legend.direction = "horizontal",
      legend.key.width = unit(2, "cm"),
      legend.key.height = unit(0.3, "cm"),
      panel.grid = element_blank()
    ) +
    guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5))
}

# Create plot
deeploc_plot <- plot_deeploc_heatmap(deeploc_file, gene_name = "ERBB2", gene_display = "HER2")
deeploc_plot
```
## Parse DeepTMHMM Results and Create Combined Visualization
To add: go to the deeptmhmm website, load your fasta files and download the .3line output file. Then keep following the vignette. 
```{r parse_deeptmhmm}
# Function to parse DeepTMHMM 3line format
parse_deeptmhmm <- function(file_path) {
  
  lines <- readLines(file_path)
  
  # Parse each 3-line block
  results <- list()
  i <- 1
  
  while (i <= length(lines)) {
    if (startsWith(lines[i], ">")) {
      # Header line
      header <- lines[i]
      transcript_id <- str_extract(header, "(?<=>)[^ ]+")
      type <- str_extract(header, "(?<=\\| )[^ ]+")
      
      # Sequence line
      sequence <- lines[i + 1]
      
      # Topology line
      topology <- lines[i + 2]
      
      # Convert topology string to data frame of segments
      segments <- data.frame(
        position = 1:nchar(topology),
        aa = strsplit(sequence, "")[[1]],
        topology = strsplit(topology, "")[[1]],
        stringsAsFactors = FALSE
      ) %>%
        mutate(
          topology_type = case_when(
            topology == "S" ~ "Signal peptide",
            topology == "O" ~ "Extracellular",
            topology == "M" ~ "Transmembrane",
            topology == "I" ~ "Intracellular",
            topology == "X" ~ "Gap",
            TRUE ~ "Unknown"
          )
        )
      
      # Add to results
      results[[transcript_id]] <- list(
        transcript_id = transcript_id,
        type = type,
        sequence = sequence,
        topology = topology,
        segments = segments
      )
      
      i <- i + 3
    } else {
      i <- i + 1
    }
  }
  
  return(results)
}

# Parse the file
deeptmhmm_file <- "../../results/HER2_analysis/HER2_deeptmhmm_predicted_topologies.3line"
deeptmhmm_results <- parse_deeptmhmm(deeptmhmm_file)
```
Before proceeding with the analysis, I need to check for what isoforms I have expression data. And moving forward I will only consider the ones I have expr data for. 

```{r}
# import the data containing expression level of the HER2 transcripts in the Xena 2016 object. 
her2_expr <- readRDS("../../results/HER2_analysis/her2_expr_filtered.rds") # filtered exp file containing the 10 HER2 transcripts
# get available transcripts without version number 
her2_available_transcripts <- her2_expr %>% 
  mutate(transcript_clean = str_remove(sample, "\\..*")) %>%
  pull(transcript_clean) %>%
  unique()
```
## Align Sequences with MSA
```{r align_sequences}
# Extract sequences for MSA
extract_sequences_for_msa <- function(deeptmhmm_results) {
  # Create AAStringSet from DeepTMHMM sequences
  seqs <- sapply(deeptmhmm_results, function(x) x$sequence)
  seq_set <- AAStringSet(seqs)
  names(seq_set) <- names(deeptmhmm_results)
  
  return(seq_set)
}

# Get all sequences from DeepTMHMM
her2_seqs_all <- extract_sequences_for_msa(deeptmhmm_results)

# Filter to keep only transcripts with expression data
# Remove version numbers from DeepTMHMM names for matching
deeptmhmm_names_clean <- str_remove(names(her2_seqs_all), "\\..*")

# Find which DeepTMHMM sequences have expression data
keep_indices <- deeptmhmm_names_clean %in% her2_available_transcripts

cat("\n=== Filtering Summary ===\n")
cat("Total DeepTMHMM sequences:", length(her2_seqs_all), "\n")
cat("Sequences with expression data:", sum(keep_indices), "\n")
cat("Sequences filtered out:", sum(!keep_indices), "\n\n")

# Keep only sequences with expression data
her2_seqs_for_msa <- her2_seqs_all[keep_indices]

cat("Kept sequences:\n")
print(names(her2_seqs_for_msa))

# Perform MSA using ClustalW
cat("\nPerforming multiple sequence alignment...\n")
her2_msa <- msa(her2_seqs_for_msa, method = "ClustalW")

# Convert to AAStringSet for easier handling
her2_aligned <- AAStringSet(her2_msa)

# View alignment info
cat("\n=== Alignment Results ===\n")
cat("Alignment width:", width(her2_aligned)[1], "positions\n")
cat("Number of sequences:", length(her2_aligned), "\n")
cat("Sequences aligned:\n")
print(names(her2_aligned))

# Show alignment
her2_aligned
```

```{r filter deeploc results}
# Filter DeepLoc results to match available transcripts
deeploc_results <- read_csv(deeploc_file, show_col_types = FALSE)

deeploc_filtered <- deeploc_results %>%
  mutate(transcript_clean = str_remove(Protein_ID, "\\..*")) %>%
  filter(transcript_clean %in% her2_available_transcripts)

cat("\n=== DeepLoc Filtering ===\n")
cat("Original DeepLoc entries:", nrow(deeploc_results), "\n")
cat("Filtered DeepLoc entries:", nrow(deeploc_filtered), "\n")

# Also filter DeepTMHMM results list
deeptmhmm_names_clean <- str_remove(names(deeptmhmm_results), "\\..*")
keep_deeptmhmm <- deeptmhmm_names_clean %in% her2_available_transcripts

deeptmhmm_filtered <- deeptmhmm_results[keep_deeptmhmm]

cat("\n=== DeepTMHMM Filtering ===\n")
cat("Original DeepTMHMM entries:", length(deeptmhmm_results), "\n")
cat("Filtered DeepTMHMM entries:", length(deeptmhmm_filtered), "\n")
```
```{r map topology to alignment}
# Function to map topology annotations to aligned sequences
map_topology_to_alignment <- function(deeptmhmm_results, aligned_sequences) {
  
  all_segments <- map_dfr(names(deeptmhmm_results), function(tid) {
    
    # Get original topology
    topology <- deeptmhmm_results[[tid]]$topology
    
    # Get aligned sequence for this transcript
    aligned_seq <- as.character(aligned_sequences[tid])
    
    # Map topology to aligned positions
    topology_chars <- strsplit(topology, "")[[1]]
    aligned_chars <- strsplit(aligned_seq, "")[[1]]
    
    # Initialize topology for aligned sequence
    aligned_topology <- character(length(aligned_chars))
    
    # Map original positions to aligned positions
    original_pos <- 1
    for (aligned_pos in 1:length(aligned_chars)) {
      if (aligned_chars[aligned_pos] == "-") {
        # Gap in alignment
        aligned_topology[aligned_pos] <- "-"
      } else {
        # Actual amino acid - use corresponding topology
        if (original_pos <= length(topology_chars)) {
          aligned_topology[aligned_pos] <- topology_chars[original_pos]
        }
        original_pos <- original_pos + 1
      }
    }
    
    # Create data frame
    data.frame(
      position = 1:length(aligned_chars),
      aa = aligned_chars,
      topology = aligned_topology,
      transcript_id = tid,
      stringsAsFactors = FALSE
    ) %>%
      mutate(
        topology_type = case_when(
          topology == "S" ~ "Signal peptide",
          topology == "O" ~ "Extracellular",
          topology == "M" ~ "Transmembrane",
          topology == "I" ~ "Intracellular",
          topology == "-" ~ "Alignment gap",
          topology == "X" ~ "Gap",
          TRUE ~ "Unknown"
        )
      )
  })
  
  return(all_segments)
}

# Map topology to aligned sequences (using FILTERED results)
cat("=== Mapping Topology to Alignment ===\n")
cat("Using", length(deeptmhmm_filtered), "transcripts with expression data\n\n")

aligned_segments <- map_topology_to_alignment(deeptmhmm_filtered, her2_aligned)

# Check result
cat("Aligned segments created:\n")
cat("Total positions:", nrow(aligned_segments), "\n")
cat("Transcripts:", length(unique(aligned_segments$transcript_id)), "\n")
cat("Alignment width:", max(aligned_segments$position), "\n\n")

cat("Sample of aligned segments:\n")
print(head(aligned_segments, 20))

# Summary by topology type
cat("\n=== Topology Distribution ===\n")
aligned_segments %>%
  group_by(topology_type) %>%
  summarise(count = n(), percentage = n()/nrow(aligned_segments)*100) %>%
  arrange(desc(count)) %>%
  print()
```
```{r plot aligned topology}
# Function to create topology visualization from aligned sequences
plot_aligned_topology <- function(aligned_segments, transcript_order = NULL) {
  
  # Set transcript order
  if (is.null(transcript_order)) {
    transcript_order <- unique(aligned_segments$transcript_id)
  }
  
  aligned_segments <- aligned_segments %>%
    mutate(transcript_id = factor(transcript_id, levels = transcript_order))
  
  # Define colors
  topology_colors <- c(
    "Signal peptide" = "#C41C24",     # Bright red
    "Extracellular" = "#FFB20F",      # Bright orange
    "Transmembrane" = "#18848C",      # Teal
    "Intracellular" = "#96BDC6",      # Light blue/teal
    "Alignment gap" = "#EDE7E3"
  )
  
  # Create plot
  p <- ggplot(aligned_segments, aes(x = position, y = transcript_id, fill = topology_type)) +
    geom_tile(height = 0.8, width = 1) +
    scale_fill_manual(values = topology_colors, name = NULL) +
    scale_x_continuous(expand = c(0, 0), breaks = seq(0, max(aligned_segments$position), 400)) +
    labs(
      x = "Amino acid position in MSA",
      y = NULL
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 14),
      axis.title.x = element_text(size = 14),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      legend.text = element_text(size = 12),
      panel.grid = element_blank(),
      legend.position = "right",
      legend.justification = "left",
      plot.margin = margin(5, 5, 5, 0)
    )
  
  return(p)
}
```

```{r make combined plot}
# Get transcript order from aligned sequences (already filtered)
transcript_order <- names(her2_aligned)

cat("=== Creating Combined Plot ===\n")
cat("Transcripts to plot:", length(transcript_order), "\n")
print(transcript_order)

# Create aligned topology plot
topology_plot_aligned <- plot_aligned_topology(aligned_segments, transcript_order = transcript_order)

# Use the already filtered DeepLoc results
# Make sure transcripts are in the same order as alignment
results_filtered <- deeploc_filtered %>%
  mutate(Protein_ID = factor(Protein_ID, levels = transcript_order)) %>%
  arrange(Protein_ID)

cat("\nDeepLoc data dimensions:", nrow(results_filtered), "rows\n")

# Define localization columns
localization_cols <- c("Cell membrane", "Cytoplasm", "Endoplasmic reticulum",
                       "Extracellular", "Golgi apparatus", "Lysosome/Vacuole",
                       "Mitochondrion", "Nucleus", "Peroxisome", "Plastid")

# Prepare plot data
plot_data <- results_filtered %>%
  dplyr::select(Protein_ID, all_of(localization_cols)) %>%
  pivot_longer(
    cols = -Protein_ID,
    names_to = "localization",
    values_to = "probability"
  )

# DeepLoc heatmap
deeploc_heatmap <- ggplot(plot_data, aes(x = localization, y = Protein_ID, fill = probability)) +
  geom_tile(color = "white", linewidth = 0.5) +
  scale_fill_gradientn(
    colors = c("#4A90B8", "#5E9DC3", "#FFFACD", "#F26D5E", "#D73027"),
    values = c(0, 0.2, 0.5, 0.8, 1),
    limits = c(0, 1),
    breaks = c(0.25, 0.50, 0.75),
    labels = c("0.25", "0.50", "0.75")
  ) +
  labs(
    title = "Target: HER2 (ERBB2)",
    x = NULL,
    y = NULL,
    fill = NULL
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 14),
    axis.text.y = element_text(size = 12, family = "mono"),
    plot.title = element_text(size = 16, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.position = "top",
    legend.direction = "horizontal",
    legend.key.width = unit(2, "cm"),
    legend.key.height = unit(0.3, "cm"),
    panel.grid = element_blank(),
    plot.margin = margin(5, 0, 5, 5)
  ) +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5))

# Combine plots with aligned topology
combined_plot_aligned <- deeploc_heatmap + topology_plot_aligned + 
  plot_layout(widths = c(1, 2), guides = "collect") &
  theme(legend.position = "top")

# Display plot
combined_plot_aligned

# Save
cat("\nSaving combined plot...\n")
ggsave("../../results/HER2_analysis/figures/erbb2_deeploc_deeptmhmm_aligned.png", 
       combined_plot_aligned, width = 14, height = 8, dpi = 300)

cat("✓ Plot saved successfully!\n")
```





```{r plot_aligned_topology, fig.width=30}
# Function to create topology visualization from aligned sequences
plot_aligned_topology <- function(aligned_segments, transcript_order = NULL) {
  
  # Set transcript order
  if (is.null(transcript_order)) {
    transcript_order <- unique(aligned_segments$transcript_id)
  }
  
  aligned_segments <- aligned_segments %>%
    mutate(transcript_id = factor(transcript_id, levels = transcript_order))
  
  # Define colors
  topology_colors <- c(
  "Signal peptide" = "#C41C24",     # Bright red
  "Extracellular" = "#FFB20F",      # Bright orange
  "Transmembrane" = "#18848C",      # Teal
  "Intracellular" = "#96BDC6",      # Light blue/teal
  "Alignment gap" = "#EDE7E3"
)
  
  # Create plot
  p <- ggplot(aligned_segments, aes(x = position, y = transcript_id, fill = topology_type)) +
    geom_tile(height = 0.8, width = 1) +
    scale_fill_manual(values = topology_colors, name = NULL) +
    scale_x_continuous(expand = c(0, 0), breaks = seq(0, max(aligned_segments$position), 400)) +
    labs(
      x = "Amino acid position in MSA",
      y = NULL
    ) +
    theme_minimal() +
    theme(
  axis.text.x = element_text(size = 14),                           # added/increased
  axis.title.x = element_text(size = 14),                          # added
  axis.text.y = element_blank(),
  axis.ticks.y = element_blank(),
  legend.text = element_text(size = 12),                           # added
  panel.grid = element_blank(),
  legend.position = "right",
  legend.justification = "left",
  plot.margin = margin(5, 5, 5, 0)
)
  
  return(p)
}
```
Make combined plot
```{r combined_plot_with_alignment, fig.width=14, fig.height=8}
# Get transcript order from aligned sequences
transcript_order <- names(her2_aligned)

# Create aligned topology plot
topology_plot_aligned <- plot_aligned_topology(aligned_segments, transcript_order = transcript_order)

# Recreate DeepLoc heatmap with same order
deeploc_file <- "../../results/HER2_analysis/HER2_deeploc21.csv"
results <- read_csv(deeploc_file, show_col_types = FALSE)

results_filtered <- results %>%
  filter(Protein_ID %in% transcript_order) %>%
  mutate(Protein_ID = factor(Protein_ID, levels = transcript_order)) %>%
  arrange(Protein_ID)

localization_cols <- c("Cell membrane", "Cytoplasm", "Endoplasmic reticulum",
                       "Extracellular", "Golgi apparatus", "Lysosome/Vacuole",
                       "Mitochondrion", "Nucleus", "Peroxisome", "Plastid")

plot_data <- results_filtered %>%
  dplyr::select(Protein_ID, all_of(localization_cols)) %>%
  pivot_longer(
    cols = -Protein_ID,
    names_to = "localization",
    values_to = "probability"
  )

# DeepLoc heatmap
deeploc_heatmap <- ggplot(plot_data, aes(x = localization, y = Protein_ID, fill = probability)) +
  geom_tile(color = "white", linewidth = 0.5) +
  scale_fill_gradientn(
  colors = c("#4A90B8", "#5E9DC3", "#FFFACD", "#F26D5E", "#D73027"),
  values = c(0, 0.2, 0.5, 0.8, 1),
  limits = c(0, 1),
  breaks = c(0.25, 0.50, 0.75),
  labels = c("0.25", "0.50", "0.75")
) +
  labs(
    title = "Target: HER2 (ERBB2)",
    x = NULL,
    y = NULL,
    fill = NULL
  ) +
  theme_minimal() +
  theme(
  axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # increased from 10
  axis.text.y = element_text(size = 12, family = "mono"),         # increased from 8
  plot.title = element_text(size = 16, face = "bold"),            # increased from 12
  legend.text = element_text(size = 12),                           # added
  legend.title = element_text(size = 12),                          # added
  legend.position = "top",
  legend.direction = "horizontal",
  legend.key.width = unit(2, "cm"),
  legend.key.height = unit(0.3, "cm"),
  panel.grid = element_blank(),
  plot.margin = margin(5, 0, 5, 5)
) +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5))

# Combine plots with aligned topology
combined_plot_aligned <- deeploc_heatmap + topology_plot_aligned + 
  plot_layout(widths = c(1, 2), guides = "collect") &
  theme(legend.position = "top")

combined_plot_aligned

# Save
ggsave("../../results/HER2_analysis/figures/erbb2_deeploc_deeptmhmm_aligned.png", 
       combined_plot_aligned, width = 14, height = 8, dpi = 300)
```
In the following I am importing the whole phenotype object, downloaded from Xena () and a filtered version of the file containing isoform expression data. I had to filter because the obj is too bog to be imported in R and filtered locally. So I did it using Computerome and then I imported the filtered file locally. 
```{r}
# Read phenotype file and the filtered file
phenotype <- read_tsv("../../data/HER2_TCGA_GTEX_category_2026.txt", show_col_types = FALSE)
her2_expr <- readRDS("../../results/HER2_analysis/her2_expr_filtered.rds") # filtered exp file containing the 24 HER2 transcripts

# # Categories to keep
# categories_to_keep <- c(
#   # GTEx tissues
#   "uterus", "testis", "stomach", "skin", "prostate", "pancreas",
#   "ovary", "lung", "liver", "kidney", "brain", "esophagus",
#   "colon", "breast", "bladder", "cervix uteri", "fallopian tube",
#   "blood vessel", "pituitary", "heart", "nerve", "small intestine",
#   "spleen", "thyroid", "adrenal gland", "salivary gland", "vagina",
#   "adipose tissue", "muscle",
#   # TCGA cancers
#   "uveal melanoma", "uterine corpus endometrioid carcinoma",
#   "uterine carcinosarcoma", "thyroid carcinoma", "thymoma",
#   "testicular germ cell tumor", "stomach adenocarcinoma",
#   "skin cutaneous melanoma", "sarcoma", "rectum adenocarcinoma",
#   "prostate adenocarcinoma", "pheochromocytoma & paraganglioma",
#   "pancreatic adenocarcinoma", "ovarian serous cystadenocarcinoma",
#   "mesothelioma", "lung squamous cell carcinoma", "lung adenocarcinoma",
#   "liver hepatocellular carcinoma", "kidney papillary cell carcinoma",
#   "kidney clear cell carcinoma", "kidney chromophobe",
#   "head & neck squamous cell carcinoma", "glioblastoma multiforme",
#   "esophageal carcinoma", "colon adenocarcinoma", "cholangiocarcinoma",
#   "cervical & endocervical cancer", "breast invasive carcinoma",
#   "brain lower grade glioma", "bladder urothelial carcinoma",
#   "adrenocortical cancer"
# )
# for now I am not filtering out any categories. 


# 1. Split TCGA_GTEX_main_category into dataset and tissue
phenotype <- phenotype %>%
  separate(TCGA_GTEX_main_category, 
           into = c("dataset", "tissue_or_disease"), 
           sep = " ", 
           extra = "merge",  # Keep everything after first space together
           remove = T)   # Keep original column too

# 2. Transform expression data from wide to long
her2_long <- her2_expr %>%
  pivot_longer(cols = -sample,
               names_to = "sample_id",
               values_to = "tpm") %>%
  dplyr::rename(transcript_id = sample)

# 3. Remove version numbers from transcript IDs
her2_long <- her2_long %>%
  mutate(transcript_clean = str_remove(transcript_id, "\\..*"))

# 4. Join with phenotype data
her2_combined <- her2_long %>%
  left_join(phenotype, by = c("sample_id" = "sample"))

# Check results
cat("\nCombined data dimensions:", dim(her2_combined), "\n")
cat("Missing phenotype data:", sum(is.na(her2_combined$dataset)), "samples\n") # those are samples with expression values but not in the phenotype file. So we can filter them out. 

# Filter out samples without phenotype data
her2_combined <- her2_combined %>%
  filter(!is.na(dataset))

cat("After filtering:", nrow(her2_combined), "rows\n")

# Save processed data
# saveRDS(her2_combined, "../../results/HER2_analysis/her2_expr_processed.rds")

# Quick summary
her2_combined %>%
  group_by(dataset) %>%
  summarise(n_samples = n_distinct(sample_id),
            n_transcripts = n_distinct(transcript_clean))
```

 [1] "ENST00000578709" "ENST00000584601" "ENST00000582818" "ENST00000584450" "ENST00000584014" "ENST00000580074"
 [7] "ENST00000445658" "ENST00000578502" "ENST00000269571" "ENST00000578199"



The expression in the object is log2(TPM + 0.001), while I want it to be log2(TPM+1), so I am converting it. 

```{r}
# Step 1: Back-transform to get original TPM
# If current value = log2(TPM + 0.001)
# Then: 2^(current value) = TPM + 0.001
# So: TPM = 2^(current value) - 0.001

# Data is log2(TPM + 0.001)
her2_combined <- her2_combined %>%
  dplyr::rename(log2_tpm001 = tpm)  # Just rename for clarity

her2_combined <- her2_combined %>%
  mutate(
    original_tpm = 2^log2_tpm001 - 0.001)  # Back-transform to original TPM  

# Check for any negative TPMs (shouldn't happen, but good to verify)
negative_tpm <- her2_combined %>% filter(original_tpm < 0)
# nrow(negative_tpm) = ~66000. We can safely assume that those are TPM = 0 because: 
# - The log2(TPM+0.001) value for all of them is -9.97. 
# - If original_tpm = 0 -> log2(0 + 0.001) = log2(0.001) = -9.9657... ≈ -9.97
# # When you back-transform:
# 2^(-9.97) - 0.001 = 0.001 - 0.001 = 0 (theoretically)
# But floating-point precision gives:
# 2^(-9.97) = 0.0009999999... (not exactly 0.001)
# 0.0009999999... - 0.001 = -0.00000001... (tiny negative!)

if (nrow(negative_tpm) > 0) {
  cat("WARNING:", nrow(negative_tpm), "samples have negative back-transformed TPM!\n")
  cat("Setting these to 0 before re-transforming...\n\n")
  
  her2_combined <- her2_combined %>%
    mutate(
      original_tpm = pmax(original_tpm, 0),  # Set negatives to 0
      log2_tpm_plus1 = log2(original_tpm + 1)  # Recalculate
    )
}

# Verification
cat("Transformed data (log2(TPM + 1)):\n")
cat("  Min:", min(her2_combined$log2_tpm_plus1), "\n")
cat("  Max:", max(her2_combined$log2_tpm_plus1), "\n")
cat("  Mean:", mean(her2_combined$log2_tpm_plus1), "\n\n")

# Optional: Save the converted data
# saveRDS(her2_combined, "../../results/HER2_analysis/her2_expr_log2plus1.rds")
# cat("\nSaved to: her2_expr_log2plus1.rds\n")
```

Making plots 
```{r}
# Create color palette
transcript_colors <- scales::hue_pal()(length(unique(her2_combined$transcript_clean)))
names(transcript_colors) <- sort(unique(her2_combined$transcript_clean))

# GTEx plot
gtex_plot <- her2_combined %>%
  filter(dataset == "GTEX") %>%
  ggplot(aes(x = tissue_or_disease, y = log2_tpm_plus1, fill = transcript_clean)) +
  geom_boxplot(outlier.size = 0.5, linewidth = 0.3) +
  scale_fill_manual(values = transcript_colors, name = "Transcript ID") +
  labs(
    title = "HER2 Isoform Expression - GTEx Normal Tissues",
    x = "Tissue",
    y = "Expression (log2(TPM + 1))"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = "right",
    legend.text = element_text(size = 8)
  )

# TCGA plot
tcga_plot <- her2_combined %>%
  filter(dataset == "TCGA") %>%
  ggplot(aes(x = tissue_or_disease, y = log2_tpm_plus1, fill = transcript_clean)) +
  geom_boxplot(outlier.size = 0.5, linewidth = 0.3) +
  scale_fill_manual(values = transcript_colors, name = "Transcript ID") +
  labs(
    title = "HER2 Isoform Expression - TCGA Cancer Types",
    x = "Cancer Type",
    y = "Expression (log2(TPM + 1))"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = "right",
    legend.text = element_text(size = 8)
  )

# Save plots
# ggsave("figures/her2_expression_gtex_log2plus1.png", gtex_plot, 
#        width = 16, height = 8, dpi = 300)
# ggsave("figures/her2_expression_tcga_log2plus1.png", tcga_plot, 
#        width = 16, height = 8, dpi = 300)

print(gtex_plot)
print(tcga_plot)
```



# Session Information

```{r session_info}
sessionInfo()
```