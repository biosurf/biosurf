<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Contributors: Lars Rønn Olsen, Christina Bligaard Pedersen, Mike Leipold, and Holden Maecker" />


<title>Data scientist’s primer to analysis of mass cytometry data</title>

<script src="site_libs/header-attrs-2.13/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; } /* Alert */
code span.an { color: #008000; } /* Annotation */
code span.at { } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #0000ff; } /* ControlFlow */
code span.ch { color: #008080; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; } /* Comment */
code span.cv { color: #008000; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #0000ff; } /* Keyword */
code span.op { } /* Operator */
code span.ot { color: #ff4000; } /* Other */
code span.pp { color: #ff4000; } /* Preprocessor */
code span.sc { color: #008080; } /* SpecialChar */
code span.ss { color: #008080; } /* SpecialString */
code span.st { color: #008080; } /* String */
code span.va { } /* Variable */
code span.vs { color: #008080; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */

.sourceCode .row {
  width: 100%;
}
.sourceCode {
  overflow-x: auto;
}
.code-folding-btn {
  margin-right: -30px;
}
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>







<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">The Single Cell Omics Group</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="blog.html">Blog</a>
</li>
<li>
  <a href="group_members.html">People</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Research
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="projects.html">Projects</a>
    </li>
    <li>
      <a href="publications.html">Publications</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Teaching
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="http://kurser.dtu.dk/course/22140">Course: Introduction to Systems Biology</a>
    </li>
    <li>
      <a href="http://kurser.dtu.dk/course/22104">Course: Health, Diseases, and Technology</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Resources
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="cytof.html">CyTOF primers</a>
    </li>
    <li>
      <a href="spectracular.html">Spectracular</a>
    </li>
    <li>
      <a href="cart.html">CAR T target evaluation</a>
    </li>
    <li>
      <a href="cyCombine.html">cyCombine vignettes</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Data scientist’s primer to analysis of mass
cytometry data</h1>
<h4 class="author">Contributors: Lars Rønn Olsen, Christina Bligaard
Pedersen, Mike Leipold, and Holden Maecker</h4>

</div>


<p><br></p>
<div id="preamble" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Preamble</h1>
<div id="the-purpose-of-this-site" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> The purpose of this
site</h2>
<p>The aim of this site is to introduce cytometry data - specifically
mass cytometry data - to data scientists and bioinformaticians not
familiar with the technology, the unique challenges relating to the
technical and biological origins of the data. The content will be
updated periodically as new tools and methods are published.</p>
<p>Along with discussions, we have included code for common processing
and analysis tasks for R. Flow cytometry as a scientific discipline has
been around for half a century at this point, and a plethora of software
and data analysis packages has been created using a multitude of
different programming languages. Common to the majority of them, is the
heavy focus on the use of The Flow Cytometry Standard (FCS) format.
While this format certainly has its strengths, it (and the analysis
software developed for it) can seem somewhat convoluted to the
uninitiated. Rather than attempting to update these packages for mass
cytometry or introduce workarounds, we here focus on extracting and
working with the raw expression matrices that most bioinformaticians
know from other data types - such as for example transcriptomics (probe
and sequence-based alike). The rationale is that once a bioinformatician
has an expression matrix and a working understanding of the technical
and biological idiosyncracies of the data, most, if not all, common
analysis algorithms for expression data can be adapted and applied.</p>
<p>We will also present a selection of common analysis tools. Not with
the explicit purpose of applying them in their packaged form, but to
explain what goes on under the hood to enable these useful analyses to
be applied in a more flexible and customizable way. The main aim here is
enabling a high level of autonomy for data scientists working with mass
cytometry data by dissecting both the data and common algorithms to its
core workable components.</p>
<p>The site consists of a series of code snippets for preparing and
analyzing the data. The examples are based on two different datasets:
One is a dataset of 21 healthy control individuals (described below and
available from <a
href="https://flowrepository.org/id/FR-FCM-ZYAJ">FlowRepository</a>),
and the other is a case/control set from <a
href="https://www.nature.com/nbt/journal/v30/n9/full/nbt.2317.html">Bodenmiller
et al. (2012)</a>, which contains 16 samples in total.</p>
<p><br></p>
</div>
<div id="the-example-data-sets" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> The example data
sets</h2>
<div id="healthy-donor-samples" class="section level3" number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> Healthy donor
samples</h3>
<p>21 samples of PBMC from healthy control individuals, stained with the
<a href="https://doi.org/10.21769/BioProtoc.1382">Leipold and Maecker
2015 protocol</a>, mixed with EQ normalization beads (Fluidigm Corp),
and acquired on a Fluidigm CyTOF Helios mass cytometer using default
acquisition parameters. The data exists in two forms: 1) the raw FCS
files as generated by the Helios, 2) the samples normalized using the
MATLAB method (described <a href="#beadnorm">below</a>) - these are
files with “normalized” in the file name. Each row in the expression
matrix is an event, of which we are only interested in those that
represent live, intact, singlet cells (i.e. we want to filter out beads,
dead cells, doublets, debris, etc.). Each column contains information
about the cells - some are parameters from the data collection by the
instrument (e.g. event length, time, etc.), some are markers primarily
used for pre-gating (DNA stain, live/dead stain, beads, etc.), some are
lineage markers (needed to determine the cell type), and some are
activation or cell state makers. Here is a table with descriptions of
each column in the example expression files.</p>
<table>
<colgroup>
<col width="7%" />
<col width="7%" />
<col width="84%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Isotope</th>
<th align="left">Parameter</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Ce140Di</td>
<td align="left">Bead</td>
<td align="left"><strong>Normalization parameter</strong> isotope unique
to Fluidigm EQ normalization beads; used to distinguish them from cells
during gating</td>
</tr>
<tr class="even">
<td align="left">In115Di</td>
<td align="left">Dead</td>
<td align="left"><strong>Pre-gating parameter</strong> Maleimide-DOTA
small molecule as live-dead (cannot efficiently enter cells with
undisturbed membranes)</td>
</tr>
<tr class="odd">
<td align="left">Ir191Di</td>
<td align="left">DNA1</td>
<td align="left"><strong>Pre-gating parameter</strong> DNA intercalator
(intact cells have high levels)</td>
</tr>
<tr class="even">
<td align="left">Ir193Di</td>
<td align="left">DNA2</td>
<td align="left"><strong>Pre-gating parameter</strong> DNA intercalator
(intact cells have high levels)</td>
</tr>
<tr class="odd">
<td align="left">Nd142Di</td>
<td align="left">CD19</td>
<td align="left"><strong>Lineage marker</strong> B cell marker</td>
</tr>
<tr class="even">
<td align="left">Nd146Di</td>
<td align="left">IgD</td>
<td align="left"><strong>Lineage marker</strong> B cell marker</td>
</tr>
<tr class="odd">
<td align="left">Dy164Di</td>
<td align="left">CD20</td>
<td align="left"><strong>Lineage marker</strong> B cell marker</td>
</tr>
<tr class="even">
<td align="left">Nd143Di</td>
<td align="left">CD4</td>
<td align="left"><strong>Lineage marker</strong> T cell marker</td>
</tr>
<tr class="odd">
<td align="left">Nd144Di</td>
<td align="left">CD8</td>
<td align="left"><strong>Lineage marker</strong> T cell marker</td>
</tr>
<tr class="even">
<td align="left">Nd148Di</td>
<td align="left">CD11c</td>
<td align="left"><strong>Lineage marker</strong> used to gate mDCs</td>
</tr>
<tr class="odd">
<td align="left">Sm149Di</td>
<td align="left">CD16</td>
<td align="left"><strong>Lineage marker</strong> used mostly to gate NK
cells</td>
</tr>
<tr class="even">
<td align="left">Nd150Di</td>
<td align="left">CD3</td>
<td align="left"><strong>Lineage marker</strong> used to gate T
cells</td>
</tr>
<tr class="odd">
<td align="left">Sm154Di</td>
<td align="left">CD14</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Monocytes</td>
</tr>
<tr class="even">
<td align="left">Gd155Di</td>
<td align="left">CCR6</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Th1/Th2/Th17 cells</td>
</tr>
<tr class="odd">
<td align="left">Gd158Di</td>
<td align="left">CXCR5</td>
<td align="left"><strong>Lineage marker</strong> used to gate T
follicular helper cells</td>
</tr>
<tr class="even">
<td align="left">Tb159Di</td>
<td align="left">CXCR3</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Th1/Th2/Th17 cells</td>
</tr>
<tr class="odd">
<td align="left">Gd160Di</td>
<td align="left">CCR7</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Naive/Central memory/Effector memory/Effector T cells</td>
</tr>
<tr class="even">
<td align="left">Dy162Di</td>
<td align="left">CD45RA</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Naive/Central memory/Effector memory/Effector T cells</td>
</tr>
<tr class="odd">
<td align="left">Ho165Di</td>
<td align="left">CD127</td>
<td align="left"><strong>Lineage marker</strong> used to gate Tregs</td>
</tr>
<tr class="even">
<td align="left">Er166Di</td>
<td align="left">CD33</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Monocytes</td>
</tr>
<tr class="odd">
<td align="left">Er168Di</td>
<td align="left">CD24</td>
<td align="left"><strong>Lineage marker</strong> used to gate
Transitional B cells</td>
</tr>
<tr class="even">
<td align="left">Yb171Di</td>
<td align="left">TCRgd</td>
<td align="left"><strong>Lineage marker</strong> used to gate
gamma-delta T cells</td>
</tr>
<tr class="odd">
<td align="left">Yb173Di</td>
<td align="left">CD123</td>
<td align="left"><strong>Lineage marker</strong> used to gate basophils
and pDCs</td>
</tr>
<tr class="even">
<td align="left">Yb174Di</td>
<td align="left">CD56</td>
<td align="left"><strong>Lineage marker</strong> used to gate NK cells
and NKT cells</td>
</tr>
<tr class="odd">
<td align="left">Yb176Di</td>
<td align="left">CD25</td>
<td align="left"><strong>Lineage marker</strong> used to gate Tregs</td>
</tr>
<tr class="even">
<td align="left">Lu175Di</td>
<td align="left">HLADR</td>
<td align="left"><strong>General protein marker</strong> activation
marker on NK and T cells</td>
</tr>
<tr class="odd">
<td align="left">In113Di</td>
<td align="left">CD57</td>
<td align="left"><strong>General protein marker</strong> differentiation
marker found on CD8+ T cells and NK cells</td>
</tr>
<tr class="even">
<td align="left">Yb172Di</td>
<td align="left">PD-1</td>
<td align="left"><strong>General protein marker</strong> found on T
cells, modulates immune function</td>
</tr>
<tr class="odd">
<td align="left">Tm169Di</td>
<td align="left">ICOS</td>
<td align="left"><strong>General protein marker</strong> found on T
cells, modulates immune function</td>
</tr>
<tr class="even">
<td align="left">Er170Di</td>
<td align="left">CD161</td>
<td align="left"><strong>General protein marker</strong> marker of IL17
producing T cells</td>
</tr>
<tr class="odd">
<td align="left">Er167Di</td>
<td align="left">CD28</td>
<td align="left"><strong>General protein marker</strong> found on T
cells, necessary for immune activation</td>
</tr>
<tr class="even">
<td align="left">Gd156Di</td>
<td align="left">CD94</td>
<td align="left"><strong>General protein marker</strong> found on CD8+ T
cells and NK cells, modulates immune function</td>
</tr>
<tr class="odd">
<td align="left">Gd157Di</td>
<td align="left">CD86</td>
<td align="left"><strong>General protein marker</strong> found on
monocytes, necessary for immune activation and survival</td>
</tr>
<tr class="even">
<td align="left">Eu151Di</td>
<td align="left">CD38</td>
<td align="left"><strong>General protein marker</strong> found on T
cells, B cells, and NK cells, necessary for immune function</td>
</tr>
<tr class="odd">
<td align="left">Sm152Di</td>
<td align="left">CD27</td>
<td align="left"><strong>General protein marker</strong> found on B and
T cells, involved in modulation and activation of immune function</td>
</tr>
<tr class="even">
<td align="left">Eu153Di</td>
<td align="left">CD11b</td>
<td align="left"><strong>General protein marker</strong> found on cell
of the innate immune system</td>
</tr>
<tr class="odd">
<td align="left">Sm147Di</td>
<td align="left">CD85j</td>
<td align="left"><strong>General protein marker</strong> found on T and
NK cells, regulates immune activation (inhibitory receptor)</td>
</tr>
<tr class="even">
<td align="left">BCKG190Di</td>
<td align="left">190BCKG</td>
<td align="left"><strong>Background</strong> not used in gating</td>
</tr>
<tr class="odd">
<td align="left">Pb208Di</td>
<td align="left">208Pb</td>
<td align="left"><strong>Background</strong> not used in gating</td>
</tr>
<tr class="even">
<td align="left">Sn120Di</td>
<td align="left">120Sn</td>
<td align="left"><strong>Background</strong> not used in gating</td>
</tr>
<tr class="odd">
<td align="left">I127Di</td>
<td align="left">127I</td>
<td align="left"><strong>Background</strong> not used in gating</td>
</tr>
<tr class="even">
<td align="left">Xe131Di</td>
<td align="left">131Xe</td>
<td align="left"><strong>Background</strong> not used in gating</td>
</tr>
</tbody>
</table>
<p>We will use this dataset for demonstration of the basic FCS file
handling and pre-processing steps as well as to demonstrate many of the
tools, but for speed and ease, we will download and process 2/21
samples. For this, one needs to log into FlowRepository and get the
files from the experiment <a
href="https://flowrepository.org/id/FR-FCM-ZYAJ">FR-FCM-ZYAJ</a>. We
will use “081216-Mike-HIMC ctrls-001_01_normalized.fcs” and
“081216-Mike-HIMC ctrls-1213_01_normalized.fcs” and rename these to
pbmc_healthy_1.fcs and pbmc_health_2.fcs.</p>
<p>An R data object with the pre-processed healthy control samples
(normalized, pre-gated, transformed - the entire process is detailed
below) can be downloaded <a
href="https://github.com/biosurf/CyTOF/blob/master/biosurf/cytof/live_2samples.Rdata">here</a>
if you are mostly interested in post-processing analyses. If so, you may
skip to <a href="#analysistasks">Data analysis section</a>.</p>
<p><br></p>
</div>
<div id="casecontrol-samples" class="section level3" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> Case/control
samples</h3>
<p>To exemplify analysis of differential abundance, we also use a
case/control dataset. We here use the data described by <a
href="https://www.nature.com/nbt/journal/v30/n9/full/nbt.2317.html">Bodenmiller
et al. (2012)</a>, which consists of 8 samples of PBMC responding to
B-cell receptor (BCR)/Fc receptor (FCR) cross-linking and 8 control PBMC
samples. The data is included in the HDCytoData R package and can be
loaded directly in R. Alternatively, the raw data can be downloaded <a
href="https://community.cytobank.org/cytobank/experiments/15713/download_files">here</a>
(download the files with “reference” and “BCR-XL” in the filename).
These data are pregated and transformed.</p>
<p><br></p>
</div>
</div>
<div id="installing-the-r-packages-you-will-need" class="section level2"
number="1.3">
<h2><span class="header-section-number">1.3</span> Installing the R
packages you will need</h2>
<p>We use a variety of packages for the analyses below. In case you are
missing some of them, here’s what you will need:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="do">## From CRAN</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>cran_packages <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;scales&quot;</span>, <span class="st">&quot;ggplot2&quot;</span>, <span class="st">&quot;dplyr&quot;</span>, <span class="st">&quot;ggridges&quot;</span>, <span class="st">&quot;RColorBrewer&quot;</span>, <span class="st">&quot;MASS&quot;</span>, <span class="st">&quot;Rtsne&quot;</span>, <span class="st">&quot;kohonen&quot;</span>, <span class="st">&quot;miscTools&quot;</span>, <span class="st">&quot;gplots&quot;</span>, <span class="st">&quot;Radviz&quot;</span>, <span class="st">&quot;igraph&quot;</span>, <span class="st">&quot;statmod&quot;</span>, <span class="st">&quot;devtools&quot;</span>, <span class="st">&quot;uwot&quot;</span>, <span class="st">&quot;cowplot&quot;</span>, <span class="st">&quot;limma&quot;</span>, <span class="st">&quot;matrixcalc&quot;</span>, <span class="st">&quot;plotrix&quot;</span>, <span class="st">&quot;JPEN&quot;</span>, <span class="st">&quot;VCA&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages()</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="do">## From BioConductor</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>bioc_packages <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;flowCore&quot;</span>, <span class="st">&quot;ConsensusClusterPlus&quot;</span>, <span class="st">&quot;cydar&quot;</span>, <span class="st">&quot;CATALYST&quot;</span>, <span class="st">&quot;ncdfFlow&quot;</span>, <span class="st">&quot;edgeR&quot;</span>, <span class="st">&quot;HDCytoData&quot;</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE))</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#     install.packages(&quot;BiocManager&quot;)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># BiocManager::install() </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="do">## From source</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>github_packages <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;nolanlab/cytofCore&quot;</span>, <span class="st">&quot;JinmiaoChenLab/cytofkit2&quot;</span>, <span class="st">&quot;cytolab/mem&quot;</span>, <span class="st">&quot;biosurf/cyCombine&quot;</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">#devtools::install_github()</span></span></code></pre></div>
<p>The R session info is located at the <a href="#sessioninfo">bottom of
the page</a>.</p>
<p><br><br></p>
</div>
</div>
<div id="the-structure-of-data-from-the-cytof-system"
class="section level1" number="2">
<h1><span class="header-section-number">2</span> The structure of data
from the CyTOF system</h1>
<p>The following sections include lots of code snippets you can use in
your CyTOF workflow.</p>
<p><br></p>
<div id="FCS" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> The Flow Cytometry
Standard (FCS) format</h2>
<p>The FCS format is a binary data file standard originally developed
for storage of flow cytometry data. As well as the ion count matrix, it
has slots for experiment information, channel information, etc.
Traditionally, ion counts have been analyzed visually using <a
href="https://www.flowjo.com/solutions/flowjo">FlowJo</a> - a commercial
software platform for analysis of single-cell cytometry experiments.
FlowJo is largely GUI-based and requires a license for both academic and
non-academic users. For more automated analysis, the following tools for
R can be used to import, manipulate and convert FCS files - or extract
the ion counts for downstream analysis in R or other programming
environments.</p>
<ul>
<li><a
href="https://bioconductor.org/packages/release/bioc/html/flowCore.html">flowCore</a>:
facilitates many FCS file related functions. Includes the option to
write new FCS files.</li>
<li><a
href="https://www.bioconductor.org/packages/release/bioc/html/flowStats.html">flowStats</a>:
package for normalizing, gating, and basic and advanced analyses of flow
cytometry data.</li>
<li><a href="https://github.com/nolanlab/cytofCore">cytofCore</a>:
contains a function to merge FCS files from disrupted CyTOF runs.</li>
<li><a
href="https://bioconductor.org/packages/release/bioc/html/CATALYST.html">CATALYST</a>:
contains functions for normalization, debarcoding, and quality
control.</li>
</ul>
<p>Example of basic FCS file handling:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the flowCore package</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(flowCore)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Read a single fcs file - remember to set the directory if you changed it since downloading the files</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>fcs_files <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="at">path =</span> <span class="st">&#39;.&#39;</span>, <span class="at">pattern=</span><span class="st">&#39;.fcs$&#39;</span>, <span class="at">full=</span><span class="cn">TRUE</span>, <span class="at">ignore.case =</span> <span class="cn">TRUE</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>fcs <span class="ot">&lt;-</span> <span class="fu">read.FCS</span>(<span class="at">filename=</span>fcs_files[<span class="dv">1</span>], <span class="at">transformation=</span><span class="cn">FALSE</span>, <span class="at">truncate_max_range =</span> <span class="cn">FALSE</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract expression matrix</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>exprs <span class="ot">&lt;-</span> fcs<span class="sc">@</span>exprs</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Explore the channels (columns in the expression matrix)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>fcs<span class="sc">@</span>parameters<span class="sc">@</span>data</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Make colnames human readable using information in the parameter data slot</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>markers <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="at">pattern =</span> <span class="st">&quot;.*_&quot;</span>, <span class="at">replacement =</span> <span class="st">&quot;&quot;</span>, <span class="at">x =</span> <span class="fu">as.vector</span>(fcs<span class="sc">@</span>parameters<span class="sc">@</span>data<span class="sc">$</span>desc))</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(exprs)[<span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(markers))] <span class="ot">&lt;-</span> markers[<span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(markers))]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Merging fcs files (in case of interrupted runs)</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># library(cytofCore)</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co"># cytofCore.concatenateDirectoryFiles(inputDir=&quot;./&quot;, outputDir=&quot;.&quot;, pattern=NULL, overwrite=F, timeParam=&quot;time&quot;)</span></span></code></pre></div>
<p><br></p>
</div>
<div id="harmonize" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Parameter
harmonization</h2>
<p>Note that these channels are <strong>freetext editable</strong> in
the Fluidigm CyTOF software. This means that if you are dealing with
files from multiple different runs from different instruments and/or
different operators (or in some cases even different staining panels),
you will need to <strong>harmonize your channel names</strong> to
compare samples. The mass information (in the “name” column) is
<em>usually</em> the most reliable, but even here errors can occur. When
in doubt, consult with the operator before renaming the channels.</p>
<p><br><br></p>
</div>
</div>
<div id="data-preprocessing" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Data preprocessing</h1>
<p>Preprocessing is essential in any mass cytometry analysis process.
Key steps in preprocessing include: <strong>bead normalization</strong>,
in which one adjusts for varying instrument performance over time;
<strong>pre-gating</strong>, in which live intact singlet cells are
obtained; <strong>compensation</strong>, which (if applicable) is used
to correct for spillover between the signals of different heavy metal
isotopes, and <strong>debarcoding</strong>, which (if applicable) is
used to separate different samples in a multiplexed experiment.</p>
<p>For convenience, we here define the different types of channels
(columns in the data matrix) used for different purposes:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pregating_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Bead&quot;</span>, <span class="st">&quot;DNA1&quot;</span>, <span class="st">&quot;DNA2&quot;</span>, <span class="st">&quot;Dead&quot;</span>, <span class="st">&quot;Event_length&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>lineage_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;CD57&quot;</span>, <span class="st">&quot;CD19&quot;</span>, <span class="st">&quot;CD4&quot;</span>, <span class="st">&quot;CD8&quot;</span>, <span class="st">&quot;IgD&quot;</span>, <span class="st">&quot;CD11c&quot;</span>, <span class="st">&quot;CD16&quot;</span>, <span class="st">&quot;CD3&quot;</span>, <span class="st">&quot;CD38&quot;</span>, <span class="st">&quot;CD27&quot;</span>, <span class="st">&quot;CD14&quot;</span>, <span class="st">&quot;CXCR5&quot;</span>, <span class="st">&quot;CCR7&quot;</span>, <span class="st">&quot;CD45RA&quot;</span>, <span class="st">&quot;CD20&quot;</span>, <span class="st">&quot;CD127&quot;</span>, <span class="st">&quot;CD33&quot;</span>, <span class="st">&quot;CD28&quot;</span>, <span class="st">&quot;CD161&quot;</span>, <span class="st">&quot;TCRgd&quot;</span>, <span class="st">&quot;CD123&quot;</span>, <span class="st">&quot;CD56&quot;</span>, <span class="st">&quot;HLADR&quot;</span>, <span class="st">&quot;CD25&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>instrument_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Time&quot;</span>, <span class="st">&quot;Event_length&quot;</span>, <span class="st">&quot;Center&quot;</span>, <span class="st">&quot;Offset&quot;</span>, <span class="st">&quot;Width&quot;</span>, <span class="st">&quot;Residual&quot;</span>)</span></code></pre></div>
<p><br></p>
<div id="beadnorm" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Bead
Normalization</h2>
<p>Because CyTOF instrument performance may vary over time (both within
a single run, but more prominently between different runs), it is
important to normalize data in a way that limits the impact of the
technical variation. The most commonly employed methods are the Fluidigm
normalization (DVS Sciences, 2013) and MATLAB normalization (<a
href="https://doi.org/10.1002/cyto.a.22271">Finck et al., 2013</a>).
Both methods are based on adding beads carrying different heavy metal
isotopes to the biological sample, and relying on the beads to leave an
extractable signature that can be used to correct signal fluctuations.
The Fluidigm normalization method uses a bead “passport” to normalize
data to a global standard, while the MATLAB method normalizes using
median bead intensities calculated across given experimental data files
(e.g. files from different runs on the same machine).</p>
<p><br></p>
<div id="fluidigm-bead-normalization" class="section level3"
number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> Fluidigm bead
normalization</h3>
<p>The Fluidigm bead normalization method is based on the calculation of
the mean isotope counts of the beads during production. This global bead
profile, called the “Bead Passport”, is unique to each lot of beads
synthesized and cannot be adjusted by the user. The first step in the
normalization process is for the software to distinguish the beads from
the cell sample in question. This is performed using all the major
isotopes of the beads (Ce140, Eu151, Eu153, Ho165, and Lu175 for the
current Fluidigm EQ beads). The normalization factor is calculated as
the ratio between the Bead Passport and the measured counts for each of
the beads. The bead channels span a large range of the mass spectrum,
and using linear interpolation to masses between or beyond the bead
masses allows for the calculation of normalization factors that are then
multiplied to each remaining mass channel distributed across the course
of the run using the time stamp. This allows for correction of decline
in instrument sensitivity during the course of running a sample, and
also normalization across samples (see figure below). However, if the
instrument used to acquire a sample differs from the Bead Passport in
overall signal intensity or in sensitivity across the mass range, the
Fluidigm normalization will “force” the sample data to conform to the
shape and signal of the Passport (see Figure 4, especially CyTOFv1 red
line).</p>
<p><br></p>
</div>
<div id="matlab-bead-normalization-finck-et-al." class="section level3"
number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> MATLAB bead
normalization (Finck et al.)</h3>
<p>The MATLAB implemented normalization algorithm created by <a
href="https://doi.org/10.1002/cyto.a.22271">Finck et al. (2013)</a>
works by modelling the sample specific drift in count reporting.
Briefly, bead singlets are manually identified by biaxial gating of each
of the five bead channels against a DNA channel. The intensities of each
bead channel over the course of a sample run, are smoothed by
calculating local medians in a 500 bead event sliding window. Then, a
baseline is calculated by taking the mean of the smoothed intensities
for each bead channel. For each bead channel, for each time point, the
slope of the linear regression from the channel origin to the given time
point is calculated, such that the residual sum of squares between the
smoothed bead intensities and the baseline is minimized. For each
recorded event, the intensity is multiplied by the slope of
corresponding the time point at which is was recorded. Since the MATLAB
normalization compares each file to the other files rather than to an
externally-determined set of values, there is typically less “forcing”
or reshaping of the data than in Fluidigm normalization (see figure
below).</p>
<div class="figure">
<img src="https://i.imgur.com/ATkadu0.png" alt="" />
<p class="caption">The effects of normalization on Raw data</p>
</div>
<p><br> The effects of normalization on Raw data is shown above.
Replicate samples were stained, then pooled and split into individual
aliquots before freezing in FBS+10% DMSO at -80°C as Takahashi et al. On
each day, the sample was thawed on ice, washed 3x in MilliQ water, then
resuspended in MilliQ water containing Fluidigm EQ beads and acquired on
the indicated CyTOF instrument model. The CyTOFv2 was later upgraded to
the v2-to-Helios instrument and another aliquot was run. During data
analysis, the EQ beads were gated separately from the cells. The linear
y-axis represents the Median Di Dual signal intensity of the indicated
mass channel: the Bead data is shown in the top row, while the Cell data
is shown on the bottom row (marker on indicated cell population). While
the Beads and Cells cover a similar mass range, the signal intensity of
the Cells on a specific instrument changes depending on the
normalization method (Raw vs. Fluidigm-ver2 vs. MATLAB).</p>
<p>It should be noted that although the bead normalization is useful for
adjusting for signal changes due primarily to the instrument
performance, it does have some limitations. First, there may be some
decrease in signal intensity in the sample that is not reflected in the
bead signal. For example, while proper fixation does generally allow
cells to withstand the osmotic force of MilliQ water, users have
reported decreases in signal intensity during acquisition of large
volume barcoded samples. Since the beads are not affected by lengthy
suspension in water, the bead signals would not change in the same way
that cell signals may. Generally, samples fixed with paraformaldehyde
seem more robust than those fixed only with commercial fix/perm
solutions. Additionally, samples are typically more stable as pellets.
Therefore, this sample signal decrease can often be limited by breaking
one large sample into aliquots that would each make 3-5 mL of diluted
sample, and only resuspending the pellet of each aliquot shortly before
collection. Second, since the beads are not stained with the assay
reagents, they are seldom sufficient for true plate-to-plate batch
correction, particularly over long periods of time when reagent lots
could change.</p>
<p><br></p>
</div>
<div id="performing-bead-normalization" class="section level3"
number="3.1.3">
<h3><span class="header-section-number">3.1.3</span> Performing bead
normalization</h3>
<p>Because the MATLAB method is more commonly used in practice, it is
the focus on this wiki. The MATLAB normalization method is implemented
with a graphical user interface (GUI), in which the user manually gates
the beads using five different bi-axial plots in which each bead metal
is plotted against the iridium channel (that measures DNA). This can be
installed from <a
href="https://github.com/nolanlab/bead-normalization/wiki/Installing-the-Normalizer">here</a>.</p>
<p>While wet lab scientists are accustomed to working with manual gating
and GUIs, such as the one in the MATLAB normalization program, this is
not the preferred method for data scientists such as bioinformaticians,
who commonly wish to analyze a large number of samples, making manual
gating very cumbersome. CATALYST has enabled this now, but before that
was possible, we implemented the MATLAB normalization algorithm in R,
such that it may be called from the command-line and run completely
without user interference. This process was carried out by translating
the MATLAB source code (available from <a
href="https://github.com/nolanlab/bead-normalization">here</a>) and
making small alterations. The R version can be downloaded from our <a
href="https://github.com/biosurf/CyTOF/blob/master/MATLAB_normalization.R">Github
repository</a>.</p>
<p>The biggest change from the original version is the fact that bead
gating is carried out automatically in the R version using a Support
Vector Machine (SVM), which was trained for this specific purpose, using
the signals of five bead channels and the DNA channel for a total of
seven data sets, for which beads had been gated manually by an
experienced wet-lab scientist. The SVM was trained in R using svm from
the <a href="https://cran.r-project.org/web/packages/e1071/">e1071
package</a>. The training data was seven samples, each comprising of
250,000 events, of which 4,068-8,715 were defined as beads. The data for
each metal channel had been transformed using the formula
ArcSinh(data)/c, in which c = 2 for CyTOF Helios data, and furthermore,
each metal channel was normalized to values between 0 and 1 for the SVM
training, to ensure maximal comparability between different samples.
Consequently, new data to be classified using the developed SVM model
should be transformed and normalized before “gating” - this is of course
incorporated in the developed script. In order to evaluate the
performance, a single-layer cross-validation setup was used, because a
preliminary run on a smaller subset using a “out-of-the-box” SVM with a
radial kernel, turned out to work satisfactory (mean accuracy of 99.997
%, with a mean precision of 99.920 %, and a mean recall of 99.971 %).
The training was carried out using a leave-one-out method, in which six
data sets was used for training and one data set was used for testing in
each round. This should allow for an unbiased performance measure. Based
on the obtained results the model was deemed acceptable, and all data
sets were used to train a final model that can be used for future
bead-normalization tasks - the developed R script requires this <a
href="https://github.com/biosurf/CyTOF/blob/master/Bead_SVM_model.Rdata">final
model</a> to run. Because the seven training samples for the SVM were
all from the CyTOF Helios platform, and they all used EQ beads with the
five bead isotopes, <sup>140</sup>Ce, <sup>151</sup>Eu,
<sup>153</sup>Eu, <sup>165</sup>Ho, and <sup>175</sup>Lu, the developed
method in R only works for data obtained using the EQ beads on a Helios
instrument. However, it could potentially easily be extended to handle
other data types - it merely requires some training data to develop the
proper SVM for gating the given data set type.</p>
<p><br></p>
</div>
</div>
<div id="compensation" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Compensation</h2>
<p>Compensation is a method for correcting signal overlap, or
“spillover”, between the different channels used in cytomtetry
experiments. While being an established method in flow cytometry, a
recent study (<a
href="https://doi.org/10.1016/j.cels.2018.02.010">Chevrier et al.,
2018</a>) highlight that mass cytometry experiments are also affected by
signal spillover. This leads to noisy expression matrices, and as a
consequence, compensation must be applied.</p>
<p>To perform compensation, you need to directly quantify the overlap
between isotopes using beads (or cells) stained with a single isotope.
Using these single-stained beads it is possible to estimate a spillover
matrix from the populations identified as belonging to each isotope, and
then one can apply the inverse of the matrix to compensate the data for
CyTOF runs through multiplication.</p>
<p>The <a
href="https://www.bioconductor.org/packages/release/bioc/html/CATALYST.html">CATALYST
tool</a> offers an implementation of a compensation method, which views
spillover as linear (traditional approach) and uses non-negative linear
least squares to avoid yielding negative expression values.
Additionally, their vignette is quite extensive and helpful.</p>
<p>But how can you tell if your data needs compensation? In reality this
may be hard, but one approach could be to use a biaxial plot to look for
unexpected correlations between channels in your dataset. E.g. you would
<em>usually</em> not expect a correlation between a barcoding channel
and a surface marker, but you may expect a correlation between two
maturity markers or two activation markers. So if you see something like
the leftmost plot below (which shows a barcoding vs. a marker channel),
you have a strong indication that something is wrong. Fortunately, it
can be corrected using CATALYST to yield the rightmost plot. For this
dataset (which is one of our own), none of the single-stained beads were
actually stained with <sup>110</sup>Pd, and consequently any signal
detected in this channel must be spillover.</p>
<div class="figure">
<img src="https://i.imgur.com/a6FzOTC.png" alt="" />
<p class="caption">Compensation example. Left: Uncompensated data with a
large spillover from the Cd114 channel to the Pd110 channel. Right:
Compensated data.</p>
</div>
<p>It is actually important to note here that while what the CyTOF user
will observe is a spillover from <sup>114</sup>Cd to <sup>110</sup>Pd,
this does not really reflect what is happening inside the machine. The
problem here is that <sup>114</sup>Cd is not “clean”, and naturally
occuring Cd will also contain some other isotopes including
<sup>110</sup>Cd (see this <a
href="http://cytoforum.stanford.edu/viewtopic.php?f=6&amp;t=417#p1329">Cytoforum
discussion</a>). The CyTOF machine is unable to distinguish different
isotopes with the same mass and the signal from <sup>110</sup>Cd is
consequently read as <sup>110</sup>Pd.</p>
<p><br></p>
</div>
<div id="debarcoding" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Debarcoding</h2>
<p>A GUI implementation of the single cell debarcoder may be installed
from <a href="https://github.com/ParkerICI/premessa">here</a> or <a
href="https://bioconductor.org/packages/release/bioc/html/CATALYST.html">here</a>,
but the CATALYST implementation may also be used without the GUI.
However, it is still advisable to adjust the barcode separation cut-offs
manually, and for this purpose it is necessary to plot the data. The
original debarcoding paper was published by <a
href="https://doi.org/10.1038/nprot.2015.020">Zunder et al. (2013)</a>,
and the basic principle is that you use combinations of palladium
isotopes to label individual samples, which you can then pool and run
together on the CyTOF machine to avoid technical variation. To separate
the different samples, one must identify events for which the difference
in the signal between the present and absent palladium channels is
clear.</p>
<p><br></p>
</div>
<div id="transformations" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Data
transformations</h2>
<div id="dealing-with-randomized-values" class="section level3"
number="3.4.1">
<h3><span class="header-section-number">3.4.1</span> Dealing with
“randomized” values</h3>
<p>When an FCS file is exported by the Helios, non-zero values are
randomized negatively and uniformly (]x-1;x]). This means that a count
of, for example, 9 will be evenly distributed between 8 and 9 for each
channel, for each event. This is mostly done for historical reasons, as
visualizing count data from the CyTOF produce different plots than
intensity data (from flow cytometers). Randomization is done (by
default) during conversion of IMD to FCS by the Fluidigm software.
Randomized counts can be converted back to the original value by
rounding every decimal up to the nearest whole number.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if counts are randomized (expression matrix should only contain integers)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>is.wholenumber <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">tol =</span> .Machine<span class="sc">$</span>double.eps<span class="sc">^</span><span class="fl">0.5</span>)  <span class="fu">abs</span>(x <span class="sc">-</span> <span class="fu">round</span>(x)) <span class="sc">&lt;</span> tol</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(<span class="fu">is.wholenumber</span>(exprs[,<span class="fu">c</span>(pregating_channels, lineage_channels)]))</span></code></pre></div>
<pre><code>## 
##   FALSE    TRUE 
## 4726283 2523717</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># You may revert back to original counts (only applicable to measured channels - i.e. exclude time, event length, etc.)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>exprs_derandomized <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">ceiling</span>(exprs[,<span class="fu">c</span>(lineage_channels, pregating_channels[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])]), exprs[,instrument_channels])</span></code></pre></div>
<p>For multidimensional analysis this is definitely recommendable not to
add unnecessary noise to the data, but for the purpose of the 2D
visualizations we are doing for pre-gating, we will leave the randomized
counts for now.</p>
<p><br></p>
</div>
<div id="arcsinh-transformation" class="section level3" number="3.4.2">
<h3><span class="header-section-number">3.4.2</span> ArcSinh
transformation</h3>
<p>Commonly, mass cytometry ion counts will be ArcSinh transformed -
this transformation will retain linearity in the low end of the count
spectrum, but it resembles a log transformation in the high end. If
counts are divided by a co-factor before the transformation, the range
of ion counts for which linearity is retained may be adjusted. For CyTOF
data, a co-factor of 5 is typically used. Transformations are done
primarily for visualization purposes and co-factors are empirically
determined. In some cases, adjusting co-factors slightly may improve
visualizations.</p>
<p>Continuing from the above code snippet for loading an FCS, the data
may be ArcSinh-transformed as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RColorBrewer)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cowplot)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Set co-factor</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>cofac <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Make arcsinh transformed expression matrix (with the exception of time and event_length, which should remain linear)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>exprs_trans <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(<span class="fu">asinh</span>(exprs[,<span class="fu">c</span>(lineage_channels, pregating_channels[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])]<span class="sc">/</span>cofac), exprs[,instrument_channels])</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot two-marker example of transformation effect</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(<span class="fu">as.data.frame</span>(exprs), <span class="fu">aes</span>(<span class="at">x =</span> CD8, <span class="at">y =</span> CD4)) <span class="sc">+</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&#39;grey&#39;</span>, <span class="at">size =</span> <span class="fl">0.05</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_density2d</span>() <span class="sc">+</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggtitle</span>(<span class="st">&#39;CD4 vs. CD8&#39;</span>) <span class="sc">+</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(exprs_trans, <span class="fu">aes</span>(<span class="at">x =</span> CD8, <span class="at">y =</span> CD4)) <span class="sc">+</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&#39;grey&#39;</span>, <span class="at">size =</span> <span class="fl">0.05</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_density2d</span>() <span class="sc">+</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggtitle</span>(<span class="st">&#39;CD4 vs. CD8 (transformed counts)&#39;</span>) <span class="sc">+</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(p1, p2, <span class="at">align =</span> <span class="st">&#39;v&#39;</span>, <span class="at">scale =</span> <span class="fl">0.9</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/asinh-1.png" width="960" /></p>
<p>Both the classic Logicle transformation and ArcSinh works by
compressing values in the upper end of the spectrum and enhancing the
resolution on the lower end:</p>
<p><img src="cytof_data_scientist_files/figure-html/logicle%20and%20arcsinh-1.png" width="960" /></p>
<p>When plotting the variation for each marker before and after
transformation, the difference is quite clear:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(reshape2)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cowplot)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>melt_exprs <span class="ot">&lt;-</span> <span class="fu">melt</span>(exprs[,lineage_channels]); melt_exprs_trans <span class="ot">&lt;-</span> <span class="fu">melt</span>(exprs_trans[,lineage_channels])</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(melt_exprs, <span class="fu">aes</span>(<span class="at">y =</span> value, <span class="at">x =</span> Var2)) <span class="sc">+</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_boxplot</span>(<span class="at">outlier.size=</span><span class="fl">0.05</span>) <span class="sc">+</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggtitle</span>(<span class="st">&#39;Raw ion counts&#39;</span>) <span class="sc">+</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">xlab</span>(<span class="st">&quot;&quot;</span>) <span class="sc">+</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>)) <span class="sc">+</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">axis.text.x =</span> <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">90</span>, <span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(melt_exprs_trans, <span class="fu">aes</span>(<span class="at">y =</span> value, <span class="at">x =</span> variable)) <span class="sc">+</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_boxplot</span>(<span class="at">outlier.size=</span><span class="fl">0.05</span>) <span class="sc">+</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggtitle</span>(<span class="st">&#39;ArcSinh transformed counts&#39;</span>) <span class="sc">+</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">xlab</span>(<span class="st">&quot;&quot;</span>) <span class="sc">+</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>)) <span class="sc">+</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">axis.text.x =</span> <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">90</span>, <span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(p1, p2, <span class="at">align =</span> <span class="st">&#39;v&#39;</span>, <span class="at">ncol =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/boxplot%20asinh-1.png" width="960" /></p>
</div>
</div>
<div id="pre-gating" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Pre-gating</h2>
<p>Pre-gating has the purpose to filter the data to consist only of
live, intact, single cells. Traditionally, this is carried out in four
steps, carried out for each sample. There are number of ways one can
semi or fully automate this process (using unsupervised or supervised
machine learning for instance), but for clarity we will perform “old
school” pre-gating below - sped up by pre-gating all samples in one go
(insofar as samples are comparable to a degree that enables this). In
the following sections, we will work on all the samples as a single
object, so first we reload the data into a data.frame.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(flowCore)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Read in your normalized files and concatenate in a data frame (in this example we subset each matrix to 10,000 random events)</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Remember to set working directory to the normalized samples</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>fcs_files <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="at">path =</span> <span class="st">&quot;.&quot;</span>, <span class="at">pattern=</span><span class="st">&#39;.fcs$&#39;</span>, <span class="at">full=</span><span class="cn">TRUE</span>, <span class="at">ignore.case =</span> <span class="cn">TRUE</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>exprs_set <span class="ot">&lt;-</span> <span class="fu">data.frame</span>()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>sample <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (f <span class="cf">in</span> fcs_files) {</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  fcs <span class="ot">&lt;-</span> <span class="fu">read.FCS</span>(<span class="at">filename=</span>f, <span class="at">transformation=</span><span class="cn">FALSE</span>, <span class="at">truncate_max_range =</span> <span class="cn">FALSE</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  exprs <span class="ot">&lt;-</span> fcs<span class="sc">@</span>exprs</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  markers <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="at">pattern =</span> <span class="st">&quot;.*_&quot;</span>, <span class="at">replacement =</span> <span class="st">&quot;&quot;</span>, <span class="at">x =</span> <span class="fu">as.vector</span>(fcs<span class="sc">@</span>parameters<span class="sc">@</span>data<span class="sc">$</span>desc))</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(exprs)[<span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(markers))] <span class="ot">&lt;-</span> markers[<span class="fu">which</span>(<span class="sc">!</span><span class="fu">is.na</span>(markers))]</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">134</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  exprs_set <span class="ot">&lt;-</span> <span class="fu">rbind</span>(exprs_set, exprs[<span class="fu">sample</span>(<span class="fu">nrow</span>(exprs), <span class="dv">10000</span>),])</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  sample <span class="ot">&lt;-</span> <span class="fu">append</span>(sample, <span class="fu">rep</span>(<span class="fu">basename</span>(f), <span class="dv">10000</span>))</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>exprs_set<span class="sc">$</span>sample <span class="ot">&lt;-</span> sample</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>instrument_channels <span class="ot">&lt;-</span> <span class="fu">append</span>(instrument_channels, <span class="st">&quot;sample&quot;</span>)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Make arcsinh transformed expression matrix (excluding channels that should remain linear - e.g. time, event length, etc.)</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>cofac <span class="ot">&lt;-</span> <span class="dv">5</span> <span class="co"># For CyTOF data, the co-factor is set to 5</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>exprs_set_trans <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">asinh</span>(exprs_set[,<span class="fu">c</span>(pregating_channels[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], lineage_channels)]<span class="sc">/</span>cofac), exprs_set[,instrument_channels])</span></code></pre></div>
<p><br></p>
<p>Insofar as all samples are run on the same instrument, with the same
panel, by the same operator, and bead normalized together, it should be
possible to avoid pre-gating all your samples one at the time, and
rather doing it in one go. You may check that the distributions of bead,
DNA, and live/dead measurements are somewhat similar:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RColorBrewer)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggridges)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cowplot)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">&lt;-</span> <span class="fu">brewer.pal</span>(<span class="dv">5</span>,<span class="st">&#39;Set1&#39;</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (c <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(pregating_channels)) {</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  p[[c]] <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(<span class="fu">as.data.frame</span>(exprs_set_trans), <span class="fu">aes_string</span>(<span class="at">x =</span> pregating_channels[c], <span class="at">y =</span> <span class="st">&quot;sample&quot;</span>)) <span class="sc">+</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_density_ridges</span>(<span class="at">color =</span> cols[c], <span class="at">fill =</span> <span class="fu">alpha</span>(cols[c], <span class="fl">0.4</span>)) <span class="sc">+</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">axis.text.y=</span><span class="fu">element_blank</span>()) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">&quot;&quot;</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(<span class="at">plotlist =</span> p, <span class="at">ncol =</span> <span class="dv">5</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/batch-1.png" width="960" /></p>
<p>Here we only have two samples. For the whole healthy PBMC dataset
with 21 samples, the plot looks like this: <img
src="https://i.imgur.com/IiwAih8.png" /></p>
<p>As can be seen all five pre-gating channels are largely comparable in
all samples, and pre-gating could be done across all samples. However,
it is still common to do this on a per-sample basis.</p>
<p><br><br></p>
<div id="gating-for-cells-beads-vs.-dna" class="section level3"
number="3.5.1">
<h3><span class="header-section-number">3.5.1</span> Gating for cells
(beads vs. DNA)</h3>
<p>The first step is to gate out beads, cell/bead dobulets, and debris.
This is done by generating a biaxial plot with a DNA channel
(e.g. <sup>191</sup>Ir) on one axis and a bead-only isotope
(<sup>140</sup>Ce) on the other. A single bead should be DNA-negative
and <sup>140</sup>Ce-positive, and cells should be DNA-positive and
<sup>140</sup>Ce-negative. Double negatives are considered to be debris
and double positives are commonly doublets. Below is a code snippet for
conducting this step after initializing as described <a
href="#fcs">above</a>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load necessary packages</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Generating a plot for gating visualization</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(exprs_set_trans, <span class="fu">aes</span>(<span class="at">x =</span> Bead, <span class="at">y =</span> DNA1)) <span class="sc">+</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&#39;grey&#39;</span>, <span class="at">size =</span> <span class="fl">0.05</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_density2d</span>(<span class="at">h =</span> <span class="fu">max</span>(<span class="fu">bandwidth.nrd</span>(exprs_set_trans[,<span class="st">&#39;Bead&#39;</span>]), <span class="fu">bandwidth.nrd</span>(exprs_set_trans[,<span class="st">&#39;DNA1&#39;</span>]))) <span class="sc">+</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>()</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Set gate boundaries - the values should be manually adjusted</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>left <span class="ot">&lt;-</span> <span class="dv">0</span>; right <span class="ot">&lt;-</span> <span class="fl">2.5</span>; lower <span class="ot">&lt;-</span> <span class="dv">5</span>; upper <span class="ot">&lt;-</span> <span class="fl">8.5</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Gating cells</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>cells <span class="ot">&lt;-</span> exprs_set_trans[exprs_set_trans[,<span class="st">&quot;Bead&quot;</span>] <span class="sc">&lt;</span> right,]; cells <span class="ot">&lt;-</span> cells[cells[,<span class="st">&quot;DNA1&quot;</span>] <span class="sc">&gt;</span> lower <span class="sc">&amp;</span> cells[,<span class="st">&quot;DNA1&quot;</span>] <span class="sc">&lt;</span> upper,]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Add gate to plot</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">geom_rect</span>(<span class="at">xmin =</span> left, <span class="at">xmax =</span> right, <span class="at">ymin =</span> lower, <span class="at">ymax =</span> upper, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">linetype =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">&#39;text&#39;</span>, <span class="at">x =</span> right <span class="sc">+</span> <span class="dv">1</span>, <span class="at">y =</span> <span class="fu">mean</span>(<span class="fu">c</span>(lower, upper)), <span class="at">label =</span> <span class="fu">paste</span>(<span class="st">&quot;Cells: &quot;</span>, <span class="fu">round</span>((<span class="fu">nrow</span>(cells)<span class="sc">/</span><span class="fu">nrow</span>(exprs_set_trans))<span class="sc">*</span><span class="dv">100</span>, <span class="at">digits=</span><span class="dv">2</span>), <span class="st">&quot;%&quot;</span>, <span class="at">sep=</span><span class="st">&quot;&quot;</span>), <span class="at">color =</span> <span class="st">&#39;red&#39;</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/pregating%201-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="gating-for-intact-cells-dna1-vs-dna2" class="section level3"
number="3.5.2">
<h3><span class="header-section-number">3.5.2</span> Gating for intact
cells (DNA1 vs DNA2)</h3>
<p>The second step is to gate for intact cells - usually by generation a
bixaial plot with the two DNA channels (<sup>191</sup>Ir and
<sup>193</sup>Ir) and gating for events, which express both at a
balanced level. If events express only little DNA it is likely debris,
but if DNA expression is too high, they are likely cell doublets.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gene rating a plot for gating visualization</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(cells, <span class="fu">aes</span>(<span class="at">x =</span> DNA1, <span class="at">y =</span> DNA2)) <span class="sc">+</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&#39;grey&#39;</span>, <span class="at">size =</span> <span class="fl">0.05</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">coord_cartesian</span>(<span class="at">xlim =</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">8</span>), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="fl">5.5</span>,<span class="fl">8.5</span>)) <span class="sc">+</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_density2d</span>() <span class="sc">+</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>()</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set gate boundaries - the values should be manually adjusted</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>left <span class="ot">&lt;-</span> <span class="fl">5.75</span>; right <span class="ot">&lt;-</span> <span class="fl">7.3</span>; lower <span class="ot">&lt;-</span> <span class="fl">6.35</span>; upper <span class="ot">&lt;-</span> <span class="fl">7.95</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Gating intact cells</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>intact <span class="ot">&lt;-</span> cells[cells[,<span class="st">&quot;DNA1&quot;</span>] <span class="sc">&gt;</span> left <span class="sc">&amp;</span> cells[,<span class="st">&quot;DNA1&quot;</span>] <span class="sc">&lt;</span> right,]; intact <span class="ot">&lt;-</span> intact[intact[,<span class="st">&quot;DNA2&quot;</span>] <span class="sc">&gt;</span> lower <span class="sc">&amp;</span> intact[,<span class="st">&quot;DNA2&quot;</span>] <span class="sc">&lt;</span> upper,]</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Add gate to plot</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">geom_rect</span>(<span class="at">xmin =</span> left, <span class="at">xmax =</span> right, <span class="at">ymin =</span> lower, <span class="at">ymax =</span> upper, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">linetype =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">&#39;text&#39;</span>, <span class="at">x =</span> right <span class="sc">+</span> <span class="fl">0.4</span>, <span class="at">y =</span> <span class="fu">mean</span>(<span class="fu">c</span>(lower, upper)), <span class="at">label =</span> <span class="fu">paste</span>(<span class="st">&quot;Intact cells: &quot;</span>, <span class="fu">round</span>((<span class="fu">nrow</span>(intact)<span class="sc">/</span><span class="fu">nrow</span>(cells))<span class="sc">*</span><span class="dv">100</span>, <span class="at">digits=</span><span class="dv">2</span>), <span class="st">&quot;%&quot;</span>, <span class="at">sep=</span><span class="st">&quot;&quot;</span>), <span class="at">color =</span> <span class="st">&#39;red&#39;</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/pregating%202-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="gating-for-singlets-event-length-vs-dna" class="section level3"
number="3.5.3">
<h3><span class="header-section-number">3.5.3</span> Gating for singlets
(event length vs DNA)</h3>
<p>The third step is to gate out doublets more specifically. This can be
done by biaxially plotting event length against a DNA channel and gating
for the events which have a length within the range of most events.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generating a plot for gating visualization</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(intact, <span class="fu">aes</span>(<span class="at">x =</span> Event_length, <span class="at">y =</span> DNA1)) <span class="sc">+</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&#39;grey&#39;</span>, <span class="at">size =</span> <span class="fl">0.05</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">coord_cartesian</span>(<span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">8</span>)) <span class="sc">+</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_density2d</span>() <span class="sc">+</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set gate boundaries - the values should be manually adjusted</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>left <span class="ot">&lt;-</span> <span class="dv">12</span>; lower <span class="ot">&lt;-</span> <span class="fl">5.65</span>; right <span class="ot">&lt;-</span> <span class="dv">22</span>; upper <span class="ot">&lt;-</span> <span class="fl">7.35</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Gating intact singlets</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>singlets <span class="ot">&lt;-</span> intact[intact[,<span class="st">&quot;Event_length&quot;</span>] <span class="sc">&gt;</span> left <span class="sc">&amp;</span> intact[,<span class="st">&quot;Event_length&quot;</span>] <span class="sc">&lt;</span> right,]</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Add gate to plot</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">geom_rect</span>(<span class="at">xmin =</span> left, <span class="at">xmax =</span> right, <span class="at">ymin =</span> lower, <span class="at">ymax =</span> upper, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">linetype =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">&#39;text&#39;</span>, <span class="at">x =</span> <span class="fu">mean</span>(<span class="fu">c</span>(left, right)), <span class="at">y =</span> lower <span class="sc">-</span> <span class="fl">0.5</span>, <span class="at">label =</span> <span class="fu">paste</span>(<span class="st">&quot;Intact singlets: &quot;</span>, <span class="fu">round</span>((<span class="fu">nrow</span>(singlets)<span class="sc">/</span><span class="fu">nrow</span>(intact))<span class="sc">*</span><span class="dv">100</span>, <span class="at">digits=</span><span class="dv">2</span>), <span class="st">&quot;%&quot;</span>, <span class="at">sep=</span><span class="st">&quot;&quot;</span>), <span class="at">color =</span> <span class="st">&#39;red&#39;</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/pregating%203-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="gating-for-live-cells-livedead-stain-vs-dna"
class="section level3" number="3.5.4">
<h3><span class="header-section-number">3.5.4</span> Gating for live
cells (live/dead stain vs DNA)</h3>
<p>The final step is to remove dead cells. This is typically carried out
by using a viability stain. This staining takes place before ligation of
antibody-probes. Because dead cells have disrupted membranes, the stain
can enter them and form bonds with intracellular molecules. The gating
itself is carried out by biaxially plotting the viability stain and a
DNA channel and gating out cells with a high amount of staining.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generating a plot for gating visualization</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(intact, <span class="fu">aes</span>(<span class="at">x =</span> Dead, <span class="at">y =</span> DNA1)) <span class="sc">+</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&#39;grey&#39;</span>, <span class="at">size =</span> <span class="fl">0.05</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>) <span class="sc">+</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">coord_cartesian</span>(<span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">8</span>)) <span class="sc">+</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_density2d</span>() <span class="sc">+</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_bw</span>()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set gate boundaries - the values should be manually adjusted</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>left <span class="ot">&lt;-</span> <span class="dv">0</span>; lower <span class="ot">&lt;-</span> <span class="fl">5.65</span>; right <span class="ot">&lt;-</span> <span class="fl">3.5</span>; upper <span class="ot">&lt;-</span> <span class="fl">7.35</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Gating live intact singlets</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>live <span class="ot">&lt;-</span> singlets[singlets[,<span class="st">&quot;Dead&quot;</span>] <span class="sc">&lt;</span> right,]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Add gate to plot</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">geom_rect</span>(<span class="at">xmin =</span> left, <span class="at">xmax =</span> right, <span class="at">ymin =</span> lower, <span class="at">ymax =</span> upper, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">linetype =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">&#39;red&#39;</span>) <span class="sc">+</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">&#39;text&#39;</span>, <span class="at">x =</span> <span class="fu">mean</span>(<span class="fu">c</span>(left, right)), <span class="at">y =</span> lower <span class="sc">-</span> <span class="fl">0.5</span>, <span class="at">label =</span> <span class="fu">paste</span>(<span class="st">&quot;Live intact singlets: &quot;</span>, <span class="fu">round</span>((<span class="fu">nrow</span>(live)<span class="sc">/</span><span class="fu">nrow</span>(singlets))<span class="sc">*</span><span class="dv">100</span>, <span class="at">digits=</span><span class="dv">2</span>), <span class="st">&quot;%&quot;</span>, <span class="at">sep=</span><span class="st">&quot;&quot;</span>), <span class="at">color =</span> <span class="st">&#39;red&#39;</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/pregating%204-1.png" width="672" /></p>
<p>Finally, you can print the recovery percentage for each sample and
save the live intact singlets to a new FCS file if you need to.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (f <span class="cf">in</span> <span class="fu">basename</span>(fcs_files)) {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">&quot;Total recovery for &quot;</span>, f, <span class="st">&quot;: &quot;</span>, <span class="fu">round</span>((<span class="fu">nrow</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>f,])<span class="sc">/</span><span class="fu">nrow</span>(exprs_set_trans[exprs_set_trans<span class="sc">$</span>sample<span class="sc">==</span>f,]))<span class="sc">*</span><span class="dv">100</span>, <span class="at">digits=</span><span class="dv">2</span>), <span class="st">&quot;%&quot;</span>, <span class="at">sep=</span><span class="st">&quot;&quot;</span>))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## [1] &quot;Total recovery for pbmc_healthy_1.fcs: 83.09%&quot;
## [1] &quot;Total recovery for pbmc_healthy_2.fcs: 83.22%&quot;</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># # Save FCS containing live intact singlets</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ff &lt;- flowFrame(as.matrix(live[,1:(ncol(live)-1)]), fcs@parameters, fcs@description)</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># suppressWarnings(write.FCS(ff2, filename = paste(&quot;./&quot;,  file, &quot;live_intact_singlets&quot;, sep=&quot;&quot;), what=&quot;numeric&quot;, delimiter = &quot;\\\\&quot;))</span></span></code></pre></div>
<p>More automated options for pre-gating can be conceived. One option is
to train a supervised model, such as a support vector machine, on a
sample for which manual gating has already been carried out. However, in
this case it is also necessary to normalize and batch correct the data
for alignment of the distributions of the pre-gating channels.</p>
<p><br></p>
</div>
</div>
<div id="batch-correction" class="section level2" number="3.6">
<h2><span class="header-section-number">3.6</span> Batch correction</h2>
<p>In cases where data was generated in multiple runs or one wishes to
compare data from different experiments, there may be unwanted technical
variation in the data. In that case, you can correct for batch effects
using one of the published tools addressing this in cytometry data. One
example is <a href="https://github.com/biosurf/cyCombine">cyCombine</a>,
which we have developed, and will briefly demonstrate the use of below.
Other, examples include CytoNorm, CytofRUV, iMUBAC, and
CyTOFBatchAdjust. A benchmark of these tools is included in the <a
href="https://doi.org/10.1038/s41467-022-29383-5">cyCombine
publication</a> and much more detailed descriptions of how to use
cyCombine - and the other tools - may be found in the <a
href="https://biosurf.org/cyCombine.html">cyCombine vignettes</a>.</p>
<p>For the purpose of demonstrating, let us construct a mini example
here:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cyCombine)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create two toy batches of bimodal densities for two toy markers</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>batch1 <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(<span class="st">&#39;CDx&#39;</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="fl">1.5</span>,<span class="fl">0.5</span>), <span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="dv">7</span>,<span class="dv">1</span>)), <span class="st">&#39;CDy&#39;</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="dv">1</span>,<span class="fl">0.5</span>), <span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="dv">5</span>,<span class="dv">1</span>)), <span class="st">&#39;batch&#39;</span> <span class="ot">=</span> <span class="st">&#39;batch1&#39;</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>batch2 <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(<span class="st">&#39;CDx&#39;</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="fl">2.1</span>,<span class="fl">0.5</span>), <span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="dv">7</span>,<span class="dv">1</span>)), <span class="st">&#39;CDy&#39;</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="dv">1</span>,<span class="fl">0.5</span>), <span class="fu">rnorm</span>(<span class="dv">500</span>,<span class="fl">7.5</span>,<span class="dv">1</span>)), <span class="st">&#39;batch&#39;</span> <span class="ot">=</span> <span class="st">&#39;batch2&#39;</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>uncorrected <span class="ot">&lt;-</span> <span class="fu">rbind.data.frame</span>(batch1, batch2)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the normalization</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>corrected <span class="ot">&lt;-</span> <span class="fu">batch_correct</span>(uncorrected)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the data before and after correction</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_density</span>(uncorrected, corrected, <span class="at">ncol =</span> <span class="dv">2</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/batch%20correct-1.png" width="672" /></p>
<p>The distributions for CDy are clearly unaligned without correction
and we need to correct for this before we can properly analyze them
together. cyCombine can help us correct the data so downstream analysis
across batches becomes meaningful.</p>
<p><br></p>
</div>
</div>
<div id="analysistasks" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Data analysis</h1>
<div id="dimred" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Dimensionality
reduction</h2>
<div id="pca" class="section level3" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> Principal component
analysis</h3>
<p>The most commonly used algorithm for dimensionality reduction in the
biological sciences is principal component analysis (PCA). For mass
cytometry data, a PCA will often capture 40-50% of the variance on the
first 2-3 PCs, but since the distance between events is linear, data
existing on a nonlinear manifold will be misrepresented <a
href="https://doi.org/10.4049/jimmunol.1500633">(Chester &amp; Maecker
2015)</a>. Whether this is an issue with CyTOF data or not depends
heavily on the source of data. For example, as cells in the
hematopoietic system develop in a hierarchical structure, the transition
between some cells will result in a continuum rather than distinct
clusters, which may not be entirely captured by PCA.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>fcs_files <span class="ot">&lt;-</span> <span class="fu">basename</span>(fcs_files)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>pca <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels], <span class="at">scale. =</span> <span class="cn">TRUE</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(<span class="fu">as.data.frame</span>(pca<span class="sc">$</span>x), <span class="fu">aes</span>(<span class="at">x =</span> PC1, <span class="at">y =</span> PC2)) <span class="sc">+</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&quot;grey&quot;</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/pca-1.png" width="672" /></p>
</div>
<div id="tsne" class="section level3" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> t-SNE</h3>
<p>The t-Distributed Stochastic Neighbor Embedding (t-SNE)
dimensionality reduction algorithm is a popular tool for dimensionality
reduction of cytometry data (van der Maaten and Hinton, 2008). The
distance between data points are represented by a t-distribution,
meaning that multidimensional distances are preserved to a greater
degree than PCA. However, there are a number of features of the
algorithm that can lead to misinterpretation by the unaware user. For
example, t-SNE (intentionally) does not preserve distances nor density,
and it only preserves nearest-neighbors if reasonable hyperparameters
are selected. This means that the sizes of the clusters are not always
indicative of the variability within the cluster, and similarly, the
distance between two clusters is not always proportional to how
different they really are. In this regard, the algorithm is quite
sensitive to the user making an informed choice of the perplexity and
epsilon hyperparameters to reasonably represent the underlying structure
of the data (See Martin Wattenberg et al.’s excellent blog post on <a
href="https://distill.pub/2016/misread-tsne/">how to use t-SNE
efficiently</a>.). Another feature that may be considered a disadvantage
to some is that t-SNE depends on a random start and is non-deterministic
even on the same data unless the same seed and iteration limit is used
for each run. Additionally, removing or adding even a few data points
from the input set will affect the layout of the remaining events, and
consequently it is not directly possible to add samples to an existing
t-SNE plot. Lastly, t-SNE does not allow for identical events, which, in
the case of immune profiling where one would expect at least some
identical cells in each cluster, means discarding or scrambling data.
Dimensionality reduction definitely has a place in mass cytometry
analysis pipelines, but for these reasons, it should be limited to
exploratory and/or post-analysis visualizations. t-SNE is implemented in
a number of languages including R, Python, C++, etc., and as a plug-in
to FlowJo X. The MATLAB implementation of t-SNE often used for mass
cytometry data in GUI pipelines is referred to as viSNE (<a
href="https://doi.org/10.1038/nbt.2594">Amir et al., 2013</a>).</p>
<p>Before running t-SNE, it is necessary to remove identical events (if
any) from the sample (duplicate rows).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(<span class="fu">duplicated</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels]))</span></code></pre></div>
<pre><code>## 
## FALSE 
##  8309</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># No duplicates here, but if so, they can be removed:</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>live <span class="ot">&lt;-</span> live[<span class="sc">!</span><span class="fu">duplicated</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels]),]</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Rtsne)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>tsne <span class="ot">&lt;-</span> <span class="fu">Rtsne</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels])</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(<span class="fu">as.data.frame</span>(tsne<span class="sc">$</span>Y), <span class="fu">aes</span>(<span class="at">x =</span> V1, <span class="at">y =</span> V2)) <span class="sc">+</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&quot;grey&quot;</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&#39;tSNE1&#39;</span>) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">&#39;tSNE2&#39;</span>) <span class="sc">+</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/tsne-1.png" width="672" /></p>
<p>Even before clustering, it is possible to get some sense of the cell
composition in a sample by selectively coloring cells by marker
expression on the t-SNE plot:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(reshape2)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],], tsne<span class="sc">$</span>Y); <span class="fu">colnames</span>(sub)[(<span class="fu">ncol</span>(sub)<span class="sc">-</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">ncol</span>(sub)] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;tSNE1&#39;</span>, <span class="st">&#39;tSNE2&#39;</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (c <span class="cf">in</span> <span class="fu">c</span>(<span class="st">&quot;CD3&quot;</span>, <span class="st">&quot;CD33&quot;</span>, <span class="st">&quot;CD19&quot;</span>, <span class="st">&quot;CD56&quot;</span>)) {</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  p[[c]] <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(sub, <span class="fu">aes</span>(<span class="at">x =</span> tSNE1, <span class="at">y =</span> tSNE2)) <span class="sc">+</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="fu">aes_string</span>(<span class="at">color =</span> c), <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme_bw</span>()</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(<span class="at">plotlist =</span> p, <span class="at">ncol =</span> <span class="dv">2</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/tsne%202-1.png" width="960" /></p>
<p><br></p>
</div>
<div id="umap" class="section level3" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> UMAP</h3>
<p>Uniform Manifold Approximation and Projection (UMAP) is a newer
addition to the family of CyTOF-applicable dimensionality reduction
methods (<a href="https://doi.org/10.1038/nbt.4314">Becht et al.,
2018</a>). It works in a fashion that is more similar to t-SNE than PCA,
which means that it also views each cell as a member of a neighborhood
of similar cells. However, it has several advantages over t-SNE. The
first one is speed. For a small dataset there may not be a significant
difference, bu you will surely notice it for a million cells.
Furthermore, UMAP preserves global distances in the data a lot better
than t-SNE. Recall that distances have no meaning in a t-SNE plot - you
can not say anything about <em>how</em> different clusters are with
t-SNE and distances between clusters tend to be fairly constant. In UMAP
plots, distances once again have meaning, although they are not linear
and directly interpretable as for PCA.</p>
<p>UMAP, like t-SNE also requires setting a seed for each run to make it
reproducible. UMAP is implemented in several languages including R and
Python.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(uwot)</span></code></pre></div>
<pre><code>## Warning: pakke &#39;Matrix&#39; blev bygget under R version 4.1.2</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">758</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>umap <span class="ot">&lt;-</span> <span class="fu">umap</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels], <span class="at">n_neighbors =</span> <span class="dv">15</span>, <span class="at">min_dist =</span> <span class="fl">0.2</span>, <span class="at">metric =</span> <span class="st">&#39;euclidean&#39;</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(<span class="fu">as.data.frame</span>(umap), <span class="fu">aes</span>(<span class="at">x =</span> V1, <span class="at">y =</span> V2)) <span class="sc">+</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">color =</span> <span class="st">&quot;grey&quot;</span>, <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&#39;UMAP1&#39;</span>) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">&#39;UMAP2&#39;</span>) <span class="sc">+</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/umap-1.png" width="672" /></p>
<p>Again, it is possible to get a pretty good insight into cell
composition in a sample by selectively coloring cells by marker
expression on the UMAP plot - you will also notice how this is similar
to the patterns seen with t-SNE:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],], umap); <span class="fu">colnames</span>(sub)[(<span class="fu">ncol</span>(sub)<span class="sc">-</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">ncol</span>(sub)] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&#39;UMAP1&#39;</span>, <span class="st">&#39;UMAP2&#39;</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (c <span class="cf">in</span> <span class="fu">c</span>(<span class="st">&quot;CD3&quot;</span>, <span class="st">&quot;CD33&quot;</span>, <span class="st">&quot;CD19&quot;</span>, <span class="st">&quot;CD56&quot;</span>)) {</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  p[[c]] <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(sub, <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="fu">aes_string</span>(<span class="at">color =</span> c), <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme_bw</span>()</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(<span class="at">plotlist =</span> p, <span class="at">ncol =</span> <span class="dv">2</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/umap%202-1.png" width="960" /></p>
<p><br><br></p>
</div>
</div>
<div id="clustering" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Cell subset detection
(clustering)</h2>
<p>Deconvoluting a cell mixture may be a goal in itself, and certainly a
necessity for meaningful comparison of samples or cell populations
whether transversal or longitudinal. The traditional approach relies on
manual gating on biaxial plots, but as the number of features are
increased, the manual strategy becomes increasingly laborious. A number
of methods are therefore seeking to automate or semi-automate the
process - not only in the interest of speed, but unsupervised methods
may also reveal cell populations overlooked when following standard
gating strategies.</p>
<p>Automated strategies are usually based on some form of clustering.
Since the hematopoietic continuum is a cellular hierarchy, the obvious
first choice is simply hierarchical clustering. However, this method is
by some considered suboptimal, usually ascribed to the need to manually
select the number of clusters based on a distance cutoff in the
resulting dendrogram. This forces the user to guess the number of
populations in the sample: selecting too many will over-separate the
data into meaningless small clusters; selecting too few will agglomerate
smaller, but potentially interesting clusters into larger ones.
Additionally, with a computational complexity of O(n) and a typical
yield of ~200.000 cells per sample, this can be a time consuming
algorithm to run on CyTOF data. However, multiple tools still utilize
hierarchical clustering in their algorithms. SPADE (Qiu et al. 2011),
for example, overcomes the computational challenges and the risk of
missing rare populations by performing density dependent down-sampling
before hierarchical clustering.</p>
<p>Phenograph (automatically decides the optimal number of clusters) and
FlowSOM (you need to provide an informed guess of the number of
clusters) were recently shown to be the best performing algorithms in a
<a href="https://doi.org/10.1002/cyto.a.23030">comparison of the main
algorithms by Weber and Robinson 2016</a>. It is of course worth
mentioning that there are many other methods available (eg. <a
href="https://doi.org/10.1073/pnas.1321405111">ACCENSE</a> and <a
href="https://github.com/JinmiaoChenLab/cytofkit2">clusterX</a>). We
will also briefly touch upon a few tools such as e.g. X-shift (Samusik
et al. 2016), or force-directed layout-based methods, e.g. SCAFFoLD
(Spitzer et al. 2015), which currently do not have R command based
interfaces, as well as cover tools with integrated clustering (e.g. <a
href="https://github.com/nolanlab/spade/wiki">SPADE</a> and <a
href="https://github.com/nolanlab/citrus">citrus</a>) in greater depth
in later sections.</p>
<p><br></p>
<div id="phenograph" class="section level3" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> Phenograph</h3>
<p>Phenograph is an algorithm which directly assigns single cells to a
particular cluster while taking the all measured dimensions into
account. Phenograph employs a k-nearest neighbor graph (k-NNG), in which
each cell is a node that is connected to its nearest neighbors by edges,
to cluster cells into phenotypically similar groups - cellular
populations. Clusters consist of nodes with high inter-connectivity.
Phenograph is implemented in the R package “cytofkit2”.</p>
<p>Phenograph also requires removal of duplicates (see <a
href="#tsne">t-SNE section</a> above).</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cytofkit2)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>clusters_pg <span class="ot">&lt;-</span> <span class="fu">cytof_cluster</span>(<span class="at">xdata =</span> live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels], <span class="at">method =</span> <span class="st">&quot;Rphenograph&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize results on PCA (using nice colors from CATALYST)</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">&lt;-</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>plot_df <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(pca<span class="sc">$</span>x, clusters_pg); plot_df<span class="sc">$</span>clusters_pg <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(plot_df<span class="sc">$</span>clusters_pg)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df, <span class="fu">aes</span>(<span class="at">x =</span> PC1, <span class="at">y =</span> PC2)) <span class="sc">+</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> clusters_pg), <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">guides</span>(<span class="at">colour =</span> <span class="fu">guide_legend</span>(<span class="at">override.aes =</span> <span class="fu">list</span>(<span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">size =</span> <span class="dv">2</span>), <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">title =</span> <span class="st">&#39;Cluster&#39;</span>)) <span class="sc">+</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols) <span class="sc">+</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/pca%20visualization-1.png" width="672" /></p>
<p>The 2D PCA visualization doesn’t provide good visual separation of
clusters. Adding an extra PC adds a significant amount of visual
resolution to the clustering, but there are better solutions -
e.g. using UMAP.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize results on UMAP plot using nice colors from CATALYST</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">&lt;-</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>plot_df <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(umap, clusters_pg); plot_df<span class="sc">$</span>clusters_pg <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(plot_df<span class="sc">$</span>clusters_pg); <span class="fu">colnames</span>(plot_df)[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&#39;UMAP&#39;</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df, <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> clusters_pg), <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">guides</span>(<span class="at">colour =</span> <span class="fu">guide_legend</span>(<span class="at">override.aes =</span> <span class="fu">list</span>(<span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">size =</span> <span class="dv">2</span>), <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">title =</span> <span class="st">&#39;Cluster&#39;</span>)) <span class="sc">+</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols) <span class="sc">+</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/umap%20visualization-1.png" width="672" />
<br></p>
<p>If you want to see how multiple samples compare with clustering and
UMAP, one approach is to pool events from multiple samples, cluster them
together, and plot them individually on in the UMAP layout which was
generated based on both samples (recall that UMAP can potentially
produce vastly different layouts if samples are run separately). Below
is an example with two samples:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample 5000 random events from each sample</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>) {</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  temp <span class="ot">&lt;-</span> live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[i],]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">58</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  sub <span class="ot">&lt;-</span> <span class="fu">rbind</span>(sub, temp[<span class="fu">sample</span>(<span class="fu">nrow</span>(temp), <span class="dv">5000</span>, <span class="at">replace=</span><span class="cn">FALSE</span>),])</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Cluster using phenograph</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>clusters_pg_2 <span class="ot">&lt;-</span> <span class="fu">cytof_cluster</span>(<span class="at">xdata =</span> sub[,lineage_channels], <span class="at">method =</span> <span class="st">&quot;Rphenograph&quot;</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Run UMAP</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">135</span>)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>umap_2 <span class="ot">&lt;-</span> <span class="fu">umap</span>(sub[,lineage_channels], <span class="at">n_neighbors =</span> <span class="dv">15</span>, <span class="at">min_dist =</span> <span class="fl">0.2</span>, <span class="at">metric =</span> <span class="st">&#39;euclidean&#39;</span>)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Get nice color scale from CATALYST</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">&lt;-</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each sample on UMAP canvas consisting of all events</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>plot_df <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(umap_2, clusters_pg_2, sub<span class="sc">$</span>sample); plot_df<span class="sc">$</span>clusters_pg_2 <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(plot_df<span class="sc">$</span>clusters_pg_2); <span class="fu">colnames</span>(plot_df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">paste0</span>(<span class="st">&#39;UMAP&#39;</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>), <span class="st">&#39;Cluster&#39;</span>, <span class="st">&#39;Sample&#39;</span>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>) {</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>  p[[s]] <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df[plot_df<span class="sc">$</span>Sample<span class="sc">==</span><span class="fu">unique</span>(plot_df<span class="sc">$</span>Sample)[s],], <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="at">data =</span> plot_df, <span class="at">pch =</span> <span class="dv">21</span>, <span class="at">color =</span> <span class="st">&#39;grey80&#39;</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> Cluster), <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">show.legend =</span> F) <span class="sc">+</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>            <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols) <span class="sc">+</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ggtitle</span>(<span class="fu">paste</span>(<span class="st">&#39;Sample&#39;</span>, s)) <span class="sc">+</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(<span class="at">plotlist =</span> p, <span class="at">ncol =</span> <span class="dv">2</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/umap%20background-1.png" width="960" /></p>
<p><br></p>
</div>
<div id="flowsom-clustering" class="section level3" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> FlowSOM
clustering</h3>
<p>FlowSOM is a method for clustering and visualization of flow and mass
cytometry data. FlowSOM uses two levels of clustering to visualize how
the intensity of cell type markers varies across the populations, and
the amount of clusters used is quite high to ensure a visualization of
even small subpopulations.</p>
<p>A standalone <a
href="https://bioconductor.org/packages/release/bioc/html/FlowSOM.html">R
package for FlowSOM</a> enables clustering, SOM, and MST visualizations.
The package is built to run on FCS files rather than expression
matrices, so here we will use the FlowSOM clustering implementation from
the cytofkit2 package.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cytofkit2)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>clusters_fs <span class="ot">&lt;-</span> <span class="fu">cytof_cluster</span>(<span class="at">xdata =</span> live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels], <span class="at">method =</span> <span class="st">&quot;FlowSOM&quot;</span>, <span class="at">FlowSOM_k =</span> <span class="dv">25</span>, <span class="at">flowSeed =</span> <span class="dv">462</span>)</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize results on UMAP plot (colors from CATALYST)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">&lt;-</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>plot_df <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(umap, clusters_fs); plot_df<span class="sc">$</span>clusters_fs <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(plot_df<span class="sc">$</span>clusters_fs); <span class="fu">colnames</span>(plot_df)[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&#39;UMAP&#39;</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df, <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> clusters_fs), <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">guides</span>(<span class="at">colour =</span> <span class="fu">guide_legend</span>(<span class="at">override.aes =</span> <span class="fu">list</span>(<span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">size =</span> <span class="dv">2</span>), <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">title =</span> <span class="st">&#39;Cluster&#39;</span>)) <span class="sc">+</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols) <span class="sc">+</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/flowsom%20umap-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="vortex" class="section level3" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> VorteX</h3>
<p>VorteX is a clustering tool, which is implemented in Java and
available as a graphical tool. VorteX includes different clustering
algorithms incl. X-shift (non-parametric, density-based), hierarchical
clustering, Mean-shift and K-medoids. In VorteX it is also easy to
visualize the results or clusterings using different plot types.</p>
<p><br></p>
</div>
<div id="scaffold" class="section level3" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> SCAFFoLD</h3>
<p>SCAFFoLD (Single-Cell Analysis by Fixed Force- and Landmark-Directed)
is, as the name indicates, a tool based on the use of force-directed
graphs. First, cells are clustered, and then the clusters are
spatialized in the plane. This means that similar clusters are put
closer to each other than dissimilar ones. This results in a map.
Furthermore, it is possible to highlight landmark populations that have
been manually gated (working as references). As a result it is possible
to compare a new sample to an old, to look for global structure changes.
Samples can be clustered both individually and together.</p>
<p>To use SCAFFoLD, you need a C++ compiler and once that is ready you
can run the program as follows:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Loading required packages</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(devtools) <span class="sc">||</span> <span class="fu">install.packages</span>(<span class="st">&quot;devtools&quot;</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">&quot;nolanlab/scaffold&quot;</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(scaffold)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Running SCAFFoLD (launching a GUI), please note that your current working directory should contain your files of interest before launching the GUI</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="fu">scaffold.run</span>()</span></code></pre></div>
<p>A complete use guide for the GUI is found <a
href="https://github.com/nolanlab/scaffold">here</a>.</p>
<p><br><br></p>
</div>
</div>
<div id="visualizing-marker-expression-in-different-clusters"
class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Visualizing marker
expression in different clusters</h2>
<p>Once cells have been clustered, examining the expression profiles of
the cells in each cluster can be used to provide clues about the type of
cells constituting the clusters. This can be done in various ways:</p>
<p><br></p>
<div id="simple-heatmap" class="section level3" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> Simple heatmap</h3>
<p>The most basic way to visually show the marker profiles of clusters
is with a simple heatmap of median marker expressions. This of course
has the drawback of ignoring the variance of the marker expression in
each cluster, but offers does offer some insights into the composition
of each cluster.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(miscTools)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(reshape2)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract medians for each marker in each cluster</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>sub_matrix <span class="ot">&lt;-</span> live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels]</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>cluster_matrix <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(clusters_pg)) {</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  cluster_matrix <span class="ot">&lt;-</span> <span class="fu">rbind</span>(cluster_matrix, <span class="fu">colMedians</span>(sub_matrix[clusters_pg<span class="sc">==</span>i,]))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Make plot</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gplots)</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">=</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="fu">heatmap.2</span>(<span class="fu">t</span>(cluster_matrix), <span class="at">col=</span><span class="fu">bluered</span>(<span class="dv">100</span>), <span class="at">trace=</span><span class="st">&quot;none&quot;</span>, <span class="at">density.info =</span> <span class="st">&quot;none&quot;</span>, <span class="at">sepcolor =</span> <span class="st">&quot;white&quot;</span>, <span class="at">sepwidth =</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.001</span>), <span class="at">colsep=</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(<span class="fu">t</span>(cluster_matrix))), <span class="at">rowsep=</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(<span class="fu">t</span>(cluster_matrix))), <span class="at">xlab=</span><span class="st">&quot;cluster&quot;</span>, <span class="at">ylab=</span><span class="st">&quot;channel&quot;</span>, <span class="at">scale=</span><span class="st">&quot;row&quot;</span>, <span class="at">ColSideColors=</span>cols[<span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(clusters_pg)])</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/heatmap-1.png" width="960" /></p>
<p><br></p>
</div>
<div id="radviz" class="section level3" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> Radviz</h3>
<p>Radviz is a visualization scheme that utilizes so-called dimensional
anchors. Each anchor (in this case, each marker) is distributed on the
circumference of a circle, and ordered in a way that markers whose
expression correlate, are located closer to each other. Each event is
then projected into the circular and located closer to markers that best
describe them. The authors use the following descriptive analogy to
explain the algorithm: “In Radviz, each dimension in the dataset is
represented by a dimensional anchor, and each dimensional anchor is
distributed evenly on a unit circle. Each line in the data set
corresponds to a point in the projection, that is linked to every
dimensional anchor by a spring. Each spring’s stiffness corresponds to
the value for that particular thing in that particular dimension. The
position of the point is defined as the point in the 2D space where the
spring’s tension is minimum.” <a
href="https://cran.r-project.org/web/packages/Radviz/vignettes/single_cell_projections.html">Read
more here</a>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Radviz)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>cell.S <span class="ot">&lt;-</span> <span class="fu">make.S</span>(<span class="fu">colnames</span>(sub_matrix))</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>cell.sim <span class="ot">&lt;-</span> <span class="fu">cosine</span>(<span class="fu">as.matrix</span>(sub_matrix))</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">946</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>optim.cell <span class="ot">&lt;-</span> <span class="fu">do.optimRadviz</span>(cell.S, cell.sim, <span class="at">iter=</span><span class="dv">100</span>, <span class="at">n=</span><span class="dv">1000</span>)</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>cell.S <span class="ot">&lt;-</span> <span class="fu">make.S</span>(<span class="fu">tail</span>(optim.cell<span class="sc">$</span>best,<span class="dv">1</span>)[[<span class="dv">1</span>]])</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>cell.rv <span class="ot">&lt;-</span> <span class="fu">do.radviz</span>(<span class="fu">as.matrix</span>(sub_matrix),cell.S)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Add cluster information</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>cell.rv<span class="sc">$</span>proj<span class="sc">$</span>data<span class="sc">$</span>Cluster <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(clusters_pg)</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Make plot using nice CATALYST colors</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">=</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cell.rv) <span class="sc">+</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> Cluster)) <span class="sc">+</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/radviz-1.png" width="672" /></p>
<p>Clusters can be visualized more clearly in a “bubble plot” version of
Radviz. In this plot, events are collapsed to the coordinates of their
respective cluster centroid, where the size of the “bubble” corresponds
to the size of the cluster.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">bubbleRadviz</span>(cell.rv, <span class="at">group =</span> <span class="st">&quot;Cluster&quot;</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Manual fix for order in legend and color of bubbles to match the plot above</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="fu">levels</span>(p<span class="sc">$</span>layers[[<span class="dv">1</span>]]<span class="sc">$</span>data<span class="sc">$</span>Cluster) <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(clusters_pg)); p<span class="sc">$</span>layers[[<span class="dv">1</span>]]<span class="sc">$</span>data<span class="sc">$</span>Cluster[<span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(clusters_pg)] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(clusters_pg)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Make the plot</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/radviz%20bubble-1.png" width="672" /></p>
<p><br></p>
</div>
<div id="penalized-supervised-star-plot" class="section level3"
number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> Penalized
supervised star plot</h3>
<p>The penalized supervised star method was presented by <a
href="https://doi.org/10.1089/vim.2018.0046">Holmes et al. (2019)</a>.
It is a way that may be used to visualize marker expression in clusters
in a 2D plot - similarly to the Radviz approach. The function is
available <a
href="https://med.stanford.edu/chronicfatiguesyndrome/research/Rcode-Visualization-Tool.html">here</a>
along with a description of the input arguments. The markers with the
longest arrows in the visualization may be interpreted as those driving
most of the clustering. Part of the output is also an importance value
(r) per marker, which is based on the ratio of inter-cluster and
intra-cluster variance. There are a few parameters to set in the
function, including <span class="math inline">\(\lambda_{1}\)</span> and
<span class="math inline">\(\lambda_{2}\)</span>. One can set multiple
of these in the call and it will automatically run a grid search to
optimize visualization.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(matrixcalc)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(plotrix)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(JPEN)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(VCA)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Define some colors to use</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">=</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co"># First, we make a dataframe with the data. For PSS, the input is a expression dataframe in which</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co"># the first column containes integer cluster IDs (1, 2, .., n) without any gaps in the integer set.</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>pss_matrix <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(clusters_pg, live[live<span class="sc">$</span>sample<span class="sc">==</span>fcs_files[<span class="dv">1</span>],lineage_channels])</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Make the plot</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>pss <span class="ot">&lt;-</span> <span class="fu">SupStarPlots</span>(<span class="at">DF =</span> pss_matrix, <span class="at">lambda1 =</span> <span class="fu">seq</span>(<span class="fl">0.001</span>, <span class="fl">20.001</span>, <span class="dv">10</span>), <span class="at">lambda2 =</span> <span class="fu">seq</span>(<span class="fl">0.001</span>, <span class="fl">20.001</span>, <span class="dv">10</span>),</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">ColOpt =</span> cols, <span class="at">M =</span> <span class="fl">1.0</span>)</span></code></pre></div>
<pre><code>##    Marker         r
## 18   CD28 22.283594
## 8     CD3 15.386340
## 15   CD20 13.679707
## 5     IgD 10.183680
## 2    CD19  9.780844
## 3     CD4  9.716805
## 6   CD11c  9.512544
## 23  HLADR  8.896232
## 17   CD33  8.671530
## 12  CXCR5  7.857189
## 7    CD16  7.807980
## 10   CD27  6.706412
## 11   CD14  6.386395
## 22   CD56  6.091298
## 1    CD57  4.560445
## 4     CD8  4.534566
## 13   CCR7  3.705037
## 16  CD127  3.608410
## 14 CD45RA  3.247039
## 21  CD123  2.085785
## 9    CD38  1.765027
## 19  CD161  1.344447
## 24   CD25  1.014503
## 20  TCRgd  0.244795</code></pre>
<p><img src="cytof_data_scientist_files/figure-html/penalized%20supervised%20star-1.png" width="768" /></p>
<p><br></p>
</div>
</div>
<div id="daanalysis" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> Analysis of
differential abundance of cell populations and proteins</h2>
<p>Once subpopulations are clustered in each sample, the next step will
often be to elucidate associations between cluster frequencies and/or
protein expression and a given condition or time. These exercises
closely resemble differential expression analyses used in
transcriptomics for decades, and the bioinformatics toolbox contains
multiple tools for basic significance tests and linear models. In
addition, the GUI tools Citrus and Statistical Scaffold were developed
for this purpose.</p>
<p>Citrus (cluster identification, characterization, and regression)
(Bruggner et al. 2014) works by combining hierarchical clustering of
events in all samples aggregated into one. Then, descriptive metrics for
each cluster are calculated, including percentage of cells assigned to
each cluster, and the median expression of lineage markers in each
cluster. These data are then used in regularized classification models
to elucidate factors differing across conditions.</p>
<p>The Statistical Scaffold method (Spitzer et al. 2017) works in a
similar way. First, populations of interest are separated by manual
gating in a representative sample. These populations will serve as
landmark nodes on a scaffold map, which serves as a template for mapping
events in the remaining samples using the cosine similarity between the
vectors of median marker values of each cluster. Lastly, the
Significance Across Microarrays permutation test (Tusher et al. 2001) is
applied to test for differences in population frequencies across
conditions.</p>
<p>One major shortcoming of existing tools is the inability to handle
more complex experimental setups, such as longitudinal studies, or
studies with multiple factors and covariates. Generalized linear models
(GLM) for differential expression analysis, popularized for
transcriptomic analyses by tools such as limma (Ritchie et al. 2015) for
microarray data and DEseq2 (Love et al. 2014) or EdgeR (Robinson et
al. 2010) for RNA sequencing data, accepts model matrices with
co-variates for complex experimental designs. Recently, Lun and
colleagues leveraged GLMs from the EdgeR software specifically for mass
cytometry data and showed these models outperform Citrus on legacy data
(Lun et al. 2017).</p>
<p>Lastly, it is important to consider that the immune system consists
of multiple functional cell populations, which are coordinated in a
complex interplay in response to various conditions. It is therefore
sometimes more informative to examine population frequencies as
dependent variables by examining correlations or ratios between
frequencies (Bailur et al. 2017). Additionally, natural variations in
the immune system are likely to mask the difference conferred by time or
conditions when looking at a single variable, even if analyzing a large
number of samples. Much like transcriptomics analyses, the immune system
does not consist of independent variables, and neither the abundance of
protein markers on individual cells nor the frequencies of individual
cell populations can be assumed independent from the remaining
variables.</p>
<p><br></p>
<div id="dacells" class="section level3" number="4.4.1">
<h3><span class="header-section-number">4.4.1</span> Analysis of
differential abundance of cells in clusters</h3>
<p>The cell counts in each cluster is the easiest to compare, as this
roughly follows a negative binomial distribution and can be flexibly
modeled using a generalized linear model (GLM) as implemented in, for
example, the edgeR package for RNA-seq transcriptomics data. In this
example, we will use the data generated by Bodenmiller et al. and
identify clusters with a differential abundance of cells between
conditions.</p>
<p>First, we import the data and create a dataframe with all the
samples:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import data as Summarized Experiment</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(HDCytoData)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>data_bcrxl <span class="ot">&lt;-</span> <span class="fu">Bodenmiller_BCR_XL_SE</span>()</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>exprs_set <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(data_bcrxl<span class="sc">@</span>assays<span class="sc">$</span>data<span class="sc">$</span>exprs, <span class="fu">rowData</span>(data_bcrxl)[,<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>])</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Asinh-transform the measured markers</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>exprs_set[,<span class="fu">which</span>(<span class="fu">colData</span>(data_bcrxl)<span class="sc">$</span>marker_class <span class="sc">!=</span> <span class="st">&#39;none&#39;</span>)] <span class="ot">&lt;-</span> <span class="fu">asinh</span>(exprs_set[,<span class="fu">which</span>(<span class="fu">colData</span>(data_bcrxl)<span class="sc">$</span>marker_class <span class="sc">!=</span> <span class="st">&#39;none&#39;</span>)]<span class="sc">/</span><span class="dv">5</span>)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Set channels</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>pregating_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;DNA-1&quot;</span>, <span class="st">&quot;DNA-2&quot;</span>)</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>lineage_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;CD45&quot;</span>, <span class="st">&quot;CD4&quot;</span>, <span class="st">&quot;CD20&quot;</span>, <span class="st">&quot;CD33&quot;</span>, <span class="st">&quot;CD123&quot;</span>, <span class="st">&quot;CD14&quot;</span>, <span class="st">&quot;IgM&quot;</span>, <span class="st">&quot;HLA-DR&quot;</span>, <span class="st">&quot;CD7&quot;</span>, <span class="st">&quot;CD3&quot;</span>)</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>functional_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;pNFkB&quot;</span>, <span class="st">&quot;pp38&quot;</span>, <span class="st">&quot;pStat5&quot;</span>, <span class="st">&quot;pAkt&quot;</span>, <span class="st">&quot;pStat1&quot;</span>, <span class="st">&quot;pSHP2&quot;</span>, <span class="st">&quot;pZap70&quot;</span>, <span class="st">&quot;pStat3&quot;</span>, <span class="st">&quot;pSlp76&quot;</span>, <span class="st">&quot;pBtk&quot;</span>, <span class="st">&quot;pPlcg2&quot;</span>, <span class="st">&quot;pErk&quot;</span>, <span class="st">&quot;pLat&quot;</span>, <span class="st">&quot;pS6&quot;</span>)</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>instrument_channels <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;Cell_length&quot;</span>, <span class="st">&quot;Time&quot;</span>, <span class="st">&quot;BC1&quot;</span>, <span class="st">&quot;BC2&quot;</span>, <span class="st">&quot;BC3&quot;</span>, <span class="st">&quot;BC4&quot;</span>, <span class="st">&quot;BC5&quot;</span>, <span class="st">&quot;BC6&quot;</span>, <span class="st">&quot;BC7&quot;</span>)</span></code></pre></div>
<p>In the interest of speed, we here down sample to 1000 random events
from each sample. Remember to normalize to the total number of events in
each sample if the full samples are used. We then cluster using the
cytofkit2 implementation of Phenograph and create a table with cell
counts in each cluster for each sample.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample 1000 random events form each sample</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">unique</span>(exprs_set<span class="sc">$</span>sample_id)) {</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  temp <span class="ot">&lt;-</span> exprs_set[exprs_set<span class="sc">$</span>sample_id<span class="sc">==</span>i,]</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">46</span>)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  sub <span class="ot">&lt;-</span> <span class="fu">rbind</span>(sub, temp[<span class="fu">sample</span>(<span class="fu">nrow</span>(temp), <span class="dv">1000</span>, <span class="at">replace=</span><span class="cn">FALSE</span>),lineage_channels])</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>sample <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">unique</span>(exprs_set<span class="sc">$</span>sample_id), <span class="at">each=</span><span class="dv">1000</span>)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cytofkit2)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>clusters_pg <span class="ot">&lt;-</span> <span class="fu">cytof_cluster</span>(<span class="at">xdata =</span> sub, <span class="at">method =</span> <span class="st">&quot;Rphenograph&quot;</span>)</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="co"># make count table - here, you should convert to percentage if samples are of uneven sizes</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>cell_counts <span class="ot">&lt;-</span> <span class="fu">table</span>(clusters_pg, sample)</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>conditions <span class="ot">&lt;-</span> data_bcrxl<span class="sc">@</span>metadata<span class="sc">$</span>experiment_info<span class="sc">$</span>group_id</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>patients <span class="ot">&lt;-</span> data_bcrxl<span class="sc">@</span>metadata<span class="sc">$</span>experiment_info<span class="sc">$</span>patient_id</span></code></pre></div>
<p>Lastly, we evaluate differential abundance in each cluster using a
NB-GLM from the edgeR package:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate differential abundance accounting for paired design</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(edgeR)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>dge <span class="ot">&lt;-</span> <span class="fu">DGEList</span>(cell_counts, <span class="at">lib.size=</span><span class="fu">rep</span>(<span class="dv">1000</span>,<span class="dv">16</span>))</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>design <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span>patients <span class="sc">+</span> conditions)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">estimateDisp</span>(dge, design)</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">glmQLFit</span>(y, design, <span class="at">robust=</span><span class="cn">TRUE</span>)</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">glmQLFTest</span>(fit, <span class="at">coef =</span> <span class="st">&#39;conditionsBCR-XL&#39;</span>)</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="fu">topTags</span>(res)</span></code></pre></div>
<pre><code>## Coefficient:  conditionsBCR-XL 
##        logFC   logCPM         F       PValue          FDR
## 11 -2.323159 15.72490 129.57413 1.323060e-20 2.646119e-19
## 15 -2.485496 16.04217  98.34914 3.747068e-17 3.747068e-16
## 9   1.907293 15.64828  72.32328 7.399927e-14 4.933284e-13
## 6   2.635548 15.35019  54.79099 2.325811e-11 1.162906e-10
## 19 -1.583595 15.75119  60.69782 7.169961e-11 2.867985e-10
## 16 -1.997757 16.35019  44.62465 2.661378e-09 8.871261e-09
## 8   1.724658 14.90839  34.93690 3.506403e-08 1.001830e-07
## 20  1.285307 14.87590  18.89864 2.978042e-05 7.445104e-05
## 10  1.048916 16.09188  15.59336 1.352719e-04 2.729150e-04
## 5   1.284918 16.17677  15.57463 1.364575e-04 2.729150e-04</code></pre>
<p>We can now visualize the log2 fold change in clusters with a
significant differential abundance between the two conditions:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize on UMAP</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(uwot)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cowplot)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RColorBrewer)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate umap coordinates</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">743</span>)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>umap <span class="ot">&lt;-</span> <span class="fu">umap</span>(sub)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Make a plotting data frame</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>plot_df <span class="ot">&lt;-</span> <span class="fu">cbind.data.frame</span>(umap, <span class="fu">as.factor</span>(clusters_pg), res<span class="sc">$</span>table<span class="sc">$</span>logFC[clusters_pg], <span class="fu">p.adjust</span>(res<span class="sc">$</span>table<span class="sc">$</span>PValue, <span class="at">method =</span> <span class="st">&#39;BH&#39;</span>)[clusters_pg], <span class="fu">rep</span>(conditions, <span class="at">each =</span> <span class="dv">1000</span>)); <span class="fu">colnames</span>(plot_df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">paste0</span>(<span class="st">&#39;UMAP&#39;</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>), <span class="st">&#39;Cluster&#39;</span>, <span class="st">&#39;log2FC&#39;</span>, <span class="st">&#39;fdr&#39;</span>, <span class="st">&#39;Group&#39;</span>)</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Adjust to only color significant p-values after FDR corection</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>plot_df<span class="sc">$</span>log2FC[plot_df<span class="sc">$</span>fdr <span class="sc">&gt;</span> <span class="fl">0.05</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Get some nice colors</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">&lt;-</span> CATALYST<span class="sc">:::</span>.cluster_cols</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the plots</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df, <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> Cluster), <span class="at">alpha =</span> <span class="fl">0.4</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols) <span class="sc">+</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>      <span class="fu">guides</span>(<span class="at">colour =</span> <span class="fu">guide_legend</span>(<span class="at">override.aes =</span> <span class="fu">list</span>(<span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">size =</span> <span class="dv">1</span>), <span class="at">ncol =</span> <span class="dv">2</span>)) <span class="sc">+</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggtitle</span>(<span class="st">&#39;Phenograph clusters&#39;</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df, <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> log2FC), <span class="at">alpha =</span> <span class="fl">0.4</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>      <span class="fu">scale_colour_gradient2</span>(<span class="at">low =</span> <span class="st">&quot;blue&quot;</span>, <span class="at">mid =</span> <span class="st">&quot;grey&quot;</span>, <span class="at">high =</span> <span class="st">&quot;red&quot;</span>) <span class="sc">+</span></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggtitle</span>(<span class="st">&#39;log2FC&#39;</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(p1, p2, <span class="at">align =</span> <span class="st">&#39;v&#39;</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/umap%20DA-1.png" width="1248" /></p>
<p>We can also visually show the cell abundance difference between
clusters using the approach in <a href="#clustering">clustering
section</a>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each sample on UMAP canvas consisting of all events</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (s <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>) {</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  p[[s]] <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">ggplot</span>(plot_df[plot_df<span class="sc">$</span>Group<span class="sc">==</span><span class="fu">levels</span>(plot_df<span class="sc">$</span>Group)[s],], <span class="fu">aes</span>(<span class="at">x =</span> UMAP1, <span class="at">y =</span> UMAP2)) <span class="sc">+</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="at">data =</span> plot_df, <span class="at">pch =</span> <span class="dv">21</span>, <span class="at">color =</span> <span class="st">&#39;grey80&#39;</span>, <span class="at">size =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>            <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color =</span> Cluster), <span class="at">alpha =</span> <span class="fl">0.6</span>, <span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">show.legend =</span> F) <span class="sc">+</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>            <span class="fu">scale_color_manual</span>(<span class="at">values =</span> cols) <span class="sc">+</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>            <span class="fu">ggtitle</span>(<span class="fu">paste</span>(<span class="fu">levels</span>(plot_df<span class="sc">$</span>Group)[s], <span class="st">&quot;samples&quot;</span>)) <span class="sc">+</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>            <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_grid</span>(<span class="at">plotlist =</span> p)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/umap%20background%20DA-1.png" width="1152" /></p>
<p><br></p>
<div id="cydar" class="section level4" number="4.4.1.1">
<h4><span class="header-section-number">4.4.1.1</span> cydar</h4>
<p>The cydar tool works in much the same way as above - clustering
followed by statistical testing for differential abundance of cells in
each cluster. In this method, the clustering is done by creating
hyperspherical clusters. This partitioning is similar to that of k-means
clustering, but here a constant distance measure (the radius) is used to
define the hyperspheres rather than dividing the events into Voronoi
cells based on the nearest mean. This means that rather than getting a
(somewhat) interpretable cluster structure (where each cluster can be
labeled as a canonical cell population), hyperspherical partitioning is
somewhat abstract and not directly interpretable. Another feature of the
hypersphere partitioning is allowing multi-membership (which one can
argue makes more biological sense than strictly allowing cells to belong
to one cluster), but this again makes the partitioning harder to
interpret in 2 or 3 dimensional space. Although harder to directly
interpret, choosing a k that is greater than “reality”, is certainly
better than selecting a k that is too small: “under-clustering” a highly
heterogeneous cell mixture such as PBMC, will potentially result in
comparing biologically irrelevant subsets. However, the trade-off of
erring on the safe side is that in order for the cydar output to be
biologically interpretable, some post-processing is necessary. The
authors provide an excellent discussion of this in their <a
href="https://www.nature.com/nmeth/journal/v14/n7/full/nmeth.4295.html">paper</a>
and in their <a
href="https://bioconductor.org/packages/release/bioc/vignettes/cydar/inst/doc/cydar.html">R
package vignette</a></p>
<p>Now for some code!</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cydar)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ncdfFlow)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample 1000 random events form each sample - cydar takes data as a list of matrices</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">unique</span>(exprs_set<span class="sc">$</span>sample)) {</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  temp <span class="ot">&lt;-</span> exprs_set[exprs_set<span class="sc">$</span>sample<span class="sc">==</span>i,]</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">23</span>)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  sub[[i]] <span class="ot">&lt;-</span> temp[<span class="fu">sample</span>(<span class="fu">nrow</span>(temp), <span class="dv">1000</span>, <span class="at">replace=</span><span class="cn">FALSE</span>),lineage_channels]</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>conditions <span class="ot">&lt;-</span> data_bcrxl<span class="sc">@</span>metadata<span class="sc">$</span>experiment_info<span class="sc">$</span>group_id</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>patient.id <span class="ot">&lt;-</span> data_bcrxl<span class="sc">@</span>metadata<span class="sc">$</span>experiment_info<span class="sc">$</span>patient_id</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>sample.id <span class="ot">&lt;-</span> <span class="fu">rep</span>(data_bcrxl<span class="sc">@</span>metadata<span class="sc">$</span>experiment_info<span class="sc">$</span>sample_id, <span class="at">each =</span> <span class="dv">1000</span>)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Count the cells into hyperspheres with a radius equal to 0.5 times the square root of the number of markers</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12</span>)</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>cd_all <span class="ot">&lt;-</span> <span class="fu">prepareCellData</span>(sub)</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>cd_all <span class="ot">&lt;-</span> <span class="fu">countCells</span>(cd_all, <span class="at">tol=</span><span class="fl">0.5</span>)</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing for significant differences in abundance - accounting for paired design</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(edgeR)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">DGEList</span>(<span class="fu">assay</span>(cd_all), <span class="at">lib.size=</span>cd_all<span class="sc">$</span>totals)</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>keep <span class="ot">&lt;-</span> <span class="fu">aveLogCPM</span>(y) <span class="sc">&gt;=</span> <span class="fu">aveLogCPM</span>(<span class="dv">5</span>, <span class="fu">mean</span>(cd_all<span class="sc">$</span>totals))</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>cd <span class="ot">&lt;-</span> cd_all[keep,]</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> y[keep,]</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>design <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span>patient.id<span class="sc">+</span>conditions)</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">estimateDisp</span>(y, design)</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">glmQLFit</span>(y, design, <span class="at">robust=</span><span class="cn">TRUE</span>)</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">glmQLFTest</span>(fit)</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Controlling the spatial FDR</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>qvals <span class="ot">&lt;-</span> <span class="fu">spatialFDR</span>(<span class="fu">intensities</span>(cd), res<span class="sc">$</span>table<span class="sc">$</span>PValue)</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>is.sig <span class="ot">&lt;-</span> qvals <span class="sc">&lt;=</span> <span class="fl">0.05</span></span></code></pre></div>
<p>In this case we find that 325 out of 551 hyperspheres contain a
significantly different number of cells between our two conditions.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the number of hypersphere with significantly different cell abundance between case and control</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(is.sig)</span></code></pre></div>
<pre><code>##    Mode   FALSE    TRUE 
## logical     226     325</code></pre>
<p><br></p>
</div>
</div>
<div id="deprot" class="section level3" number="4.4.2">
<h3><span class="header-section-number">4.4.2</span> Analysis of
differential expression of proteins between clusters</h3>
<p>The expression of lineage markers between different clusters will
naturally differ, as differential expression is the very basis for all
the clustering algorithms discussed here. However, it may be of interest
to examine whether the expression of functional markers differs within a
cluster that is considered to represent the same cell type in two
different conditions.</p>
<p>Currently, the most widely utilized approach is to compare the median
expression a given protein in each sample across conditions for a
specific cluster. There are some potentially <strong>serious caveats to
this approach</strong> which we will discuss a bit further down. But
first, let’s go through a simple example of this common approach:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample 1000 random events form each sample</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">unique</span>(exprs_set<span class="sc">$</span>sample)) {</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  temp <span class="ot">&lt;-</span> exprs_set[exprs_set<span class="sc">$</span>sample<span class="sc">==</span>i,]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">84</span>)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>  sub <span class="ot">&lt;-</span> <span class="fu">rbind</span>(sub, temp[<span class="fu">sample</span>(<span class="fu">nrow</span>(temp), <span class="dv">1000</span>, <span class="at">replace=</span><span class="cn">FALSE</span>),<span class="fu">c</span>(lineage_channels, functional_channels)])</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>sample <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">unique</span>(exprs_set<span class="sc">$</span>sample), <span class="at">each=</span><span class="dv">1000</span>)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="co"># cluster</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cytofkit2)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>clusters_pg <span class="ot">&lt;-</span> <span class="fu">cytof_cluster</span>(<span class="at">xdata =</span> sub[,lineage_channels], <span class="at">method =</span> <span class="st">&quot;Rphenograph&quot;</span>)</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Make median expression table (samples x functional proteins) for each cluster</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a><span class="co"># - here we generate the table for cluster 1</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>sub_cluster <span class="ot">&lt;-</span> sub[clusters_pg<span class="sc">==</span><span class="dv">1</span>,functional_channels]</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>sample_cluster <span class="ot">&lt;-</span> sample[clusters_pg<span class="sc">==</span><span class="dv">1</span>]</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>exprs_cluster <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">unique</span>(sample_cluster)) {</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>  exprs_cluster <span class="ot">&lt;-</span> <span class="fu">cbind</span>(exprs_cluster, miscTools<span class="sc">::</span><span class="fu">colMedians</span>(sub_cluster[sample_cluster<span class="sc">==</span>i,]))</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(exprs_cluster) <span class="ot">&lt;-</span> <span class="fu">unique</span>(sample_cluster)</span></code></pre></div>
<p>Again we are left with a simple expression matrix, to which you can
apply your favorite statistics. Here we use a linear model:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Basic DE test using limma</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(limma)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>conditions_test <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">gsub</span>(<span class="st">&quot;.*(Reference|BCR-XL).*&quot;</span>, <span class="st">&quot;</span><span class="sc">\\</span><span class="st">1&quot;</span>, <span class="fu">colnames</span>(exprs_cluster)))</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>patient_test <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">gsub</span>(<span class="st">&quot;.*patient(.)_.*&quot;</span>, <span class="st">&quot;</span><span class="sc">\\</span><span class="st">1&quot;</span>, <span class="fu">colnames</span>(exprs_cluster)))</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>design <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span>patient_test<span class="sc">+</span>conditions_test)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">lmFit</span>(exprs_cluster, design)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">eBayes</span>(fit)</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="fu">topTable</span>(fit, <span class="at">coef=</span><span class="st">&quot;conditions_testReference&quot;</span>, <span class="at">number=</span><span class="st">&quot;inf&quot;</span>, <span class="at">adjust.method=</span><span class="st">&quot;bonferroni&quot;</span>)</span></code></pre></div>
<pre><code>##               logFC      AveExpr          t      P.Value   adj.P.Val          B
## pNFkB   1.122351516  1.522762047  6.9921970 0.0001118117 0.001565364  1.6820193
## pBtk    0.291127735  0.094915744  6.0447849 0.0003038642 0.004254099  0.6457291
## pAkt   -0.434887239  2.042865026 -4.1624987 0.0031326863 0.043857608 -1.7925238
## pSlp76  0.190229055  0.024751506  3.8081627 0.0051459466 0.072043252 -2.3095335
## pp38    0.720171096  0.301162316  3.1650575 0.0132397265 0.185356171 -3.2857430
## pLat   -0.228809018  0.264863056 -2.8417041 0.0216854614 0.303596460 -3.7886220
## pStat1 -0.420684203  0.991877897 -2.7574389 0.0246986828 0.345781559 -3.9201382
## pStat3 -0.132816457  0.083995254 -2.1470853 0.0639592407 0.895429370 -4.8624590
## pErk   -0.241943128  0.174066127 -1.7215685 0.1233329347 1.000000000 -5.4829087
## pS6    -0.069115380 -0.008251051 -1.6690707 0.1335363558 1.000000000 -5.5555782
## pPlcg2 -0.193210279  0.249821843 -1.6260164 0.1424801841 1.000000000 -5.6143702
## pZap70 -0.032194520 -0.057617285 -1.6137051 0.1451368594 1.000000000 -5.6310419
## pSHP2  -0.022827538 -0.066722694 -1.5205028 0.1667571584 1.000000000 -5.7551120
## pStat5  0.006800125 -0.062395905  0.4910166 0.6365596727 1.000000000 -6.7519840</code></pre>
<p>So in cluster 1, we have three significantly differentially expressed
proteins between the Reference and BCR-XL samples, based on the median
expression of the protein.</p>
<p>The most glaring (potential) issue with using the median expression
is that we assume homoscedasticity and ignore the variance of the
expression within each sample. Another potential issue is that for the
linear models, we assume that the expression values (and median values)
follow a Gaussian distribution. As mentioned earlier, the arcsinh
transformation is first and foremost a cosmetic operation for biaxial
plots, and the raw counts (without the default randomization by the
Fluidigm software) roughly follows a (somewhat zero-inflated) negative
binomial distribution. As such, a more appropriate statistic may be
adopted from common practices in single cell transcriptomics analyses,
but the error model has to be adapted: for example, dropout events are
not an issue in mass cytometry, but the isotope counts are subject to
stochastic noise and antibody binding introduces some fairly systematic
noise (as discussed in our manuscript) that should be modeled
appropriately. Lastly, we measure far fewer features in mass cytometry,
but vastly more observations compared with single cell transcriptomics.
Until such a model is formulated, linear modeling of median marker
expression remains the state-of-the-art.</p>
<p><br></p>
</div>
<div id="citrus" class="section level3" number="4.4.3">
<h3><span class="header-section-number">4.4.3</span> Citrus</h3>
<p>One of the tools that utilizes this method is Citrus (cluster
identification, characterization, and regression). The Citrus algorithm
works by first doing an optional down-sampling to a user-specified
number of events from each sample followed by hierarchical clustering of
the pooled cells. When clusters are defined, Citrus utilizes algorithms
from the SAM (statistical analysis of microarrays) package to calculate
1) differential abundance of cells in clusters across the defined
conditions, 2) differential median protein expression in each cluster
across the defined conditions, and 3) trains a lasso regularized
logistic regression and nearest shrunken centroids method to identify a
subset of cluster features that best stratifies the condition from the
control samples. Citrus is primarily implemented as a GUI, but an <a
href="https://github.com/nolanlab/citrus">R package</a> allow for
command-based execution. In either case, Citrus takes only FCS files.
The method is described in the <a
href="https://doi.org/10.1073/pnas.1408792111">2014 paper by Bruggner et
al.</a>.</p>
<p><br></p>
</div>
</div>
<div id="celltypes" class="section level2" number="4.5">
<h2><span class="header-section-number">4.5</span> Cell type
assignment</h2>
<p>In order to finally draw biological conclusions from the clustering
and differential population frequency and/or protein expression
analyses, differential population frequency analyses, or differential
marker expression analyses, it is necessary to assign a cell type to
each cluster. For domain experts, this may be as simple as comparatively
surveying the marker expression in each cluster, for example by
generating clusters vs. markers heatmaps or aided by tools such as
Marker Enrichment Modelling (MEM) (Diggins et al. 2017), which can be
used to label clusters with a simpler human readable marker enrichment
profile. Other tools such as flowCL (Courtot et al. 2015), ACDC (Lee et
al. 2017) or the LDA-approach by <a
href="https://doi.org/10.1002/cyto.a.23738">Abdelaal et al. (2019)</a>
enables automated assignment of labels to clusters, but flowCL requires
the user to make decisions about when a marker is expressed or not and
uses the phenotype label to assign the most likely label (although it is
actually not working, currently), and ACDC requires users to define
population labels with a markers x populations binary expression
matrix.</p>
<p>The lack of a fully automated cell type assignment workflow is most
likely due to the fact that assigning canonical populations is trivial
for domain experts, while rare populations may be subject to
disagreement, and novel populations not yet named are likely to be
present. However, for the computationally inclined, the Python
implementation of ACDC can be used to perform a label estimate on
clustered data.</p>
<p><br></p>
<div id="acdc" class="section level3" number="4.5.1">
<h3><span class="header-section-number">4.5.1</span> ACDC</h3>
<p>Automated Cell-type Discovery and Classiffcation (ACDC) takes a cell
type-marker table, in which each cell type is related to a marker
profile. The table can contain values 1 (present), -1 (absent), 0/NA (do
not consider) for each marker and cell type combination. This table can
be completely customized to suit the measured markers of a study and
include the cell types one wishes to study. The values should be based
on the biological knowledge of marker expression of different cell types
(e.g. all T cells express CD3). Then each cell is classified resulting
in a clustering in which each cluster is labeled as a specific cell
type. This method is consequently biased by the cell-type marker table
applied, but it may be useful in certain situations. ACDC is available
for Python and tutorials for running the program can be found <a
href="https://github.com/howchihlee/ACDC_tutorial/tree/master/notebooks">here</a>.
We have also made <a
href="https://github.com/biosurf/CyTOF/blob/master/ACDC_BioSurf.ipynb">our
own IPython Notebook-tutorial</a> for running ACDC.</p>
<p>Three different cell-type marker tables can be accessed in our Git
repository: The <a
href="https://github.com/biosurf/CyTOF/blob/master/AML_table.csv">AML
table</a>, the <a
href="https://github.com/biosurf/CyTOF/blob/master/BMMC_table.csv">BMMC
table</a>, and a <a
href="https://github.com/biosurf/CyTOF/blob/master/Leipold_table.csv">table
defined by Michael D. Leipold</a>. The two first tables were derived
from <a
href="https://www.cytobank.org/nolanlab/reports/Levine2015.html">Levine
et al.</a> and processed into the csv format by the original
ACDC-developers.</p>
<p><br></p>
</div>
<div id="marker-enrichment-modeling" class="section level3"
number="4.5.2">
<h3><span class="header-section-number">4.5.2</span> Marker Enrichment
Modeling</h3>
<p>The Marker Enrichment Modeling (MEM) tools describes cellular subsets
by the features that are enriched for each population using a weighted
marker expression profile. MEM describes the characteristics of
different clusters in the context of the other cells in the sample -
e.g. certain surface markers specifically enriched in the given
cluster.</p>
<p>The output is a weighted marker expression profile of each cluster,
which can be translated into a “human readable” label for each cluster.
In this example, we use the clusters from phenograph and create a list
of human readable labels for each cluster.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MEM)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate enrichment scores in clusters from Bodenmiller set</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>mem <span class="ot">&lt;-</span> <span class="fu">MEM</span>(<span class="fu">cbind</span>(sub, <span class="at">cluster =</span> clusters_pg))</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co"># This creates a table of enrichment scores for each marker in each cluster. Round these scores to get a label as presented in their paper</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>mem <span class="ot">&lt;-</span> <span class="fu">round</span>(mem<span class="sc">$</span>MEM_matrix[[<span class="dv">1</span>]])</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Viewing the cluster labels</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>mem</span></code></pre></div>
<pre><code>##    CD45 CD4 CD20 CD33 CD123 CD14 IgM HLA-DR CD7 CD3 pNFkB pp38 pStat5 pAkt
## 1     0   4    2    0     0    1   0     -4   2   4     0    0      0   -1
## 2     0  -8    2    0     0    1   0     -4   2   2    -1   -2      0    0
## 3     0  -4    2    0     0    1   0     -2   4   2     1    0      0    1
## 4     0  -8    2    0     0    0   0     -1   4  -5    -1   -2      0    0
## 5     0  -8    2    0     2    0   0      0   3   0     0   -1      0    1
## 6     0   6    2    0     0    1   0      1   4   3     0   -1      0    1
## 7     0  -8    2    0     0    1   0      2   3   3    -1   -2      0    1
## 8     0  -6    5    0     0    0   3      3  -8  -4     0    0      0    0
## 9     0  -8    1    0     0    2   0      1   3   1     0   -1      0    1
## 10    0   6    2    0     0    1   0     -3   3   4     1    1      0    0
## 11    0   1    0    1     0    1   0      3  -7  -2     1    1      0    1
## 12    0   1    2    0     0    0   0     -2   4  -6     1    0      0    0
## 13   -4  -5    0    0     0    1   0     -2  -5  -5    -1   -1      0   -4
## 14    0  -8    2    0     0    1   0     -4  -9   1    -1   -1      0   -2
## 15    1   4    0    0     0    1   0     -4  -8   4     0    0      0   -1
## 16    0   6    1    0     2    0   0     -1   2   4     0    0      0    1
## 17   -1  -3    1    0     3    0   0      0  -8  -4     0    0      0    0
## 18    0   6    1    0     0    2   0     -2   2   4     0   -1      0    1
## 19    0  -8    1    0     0    1   0     -3  -7  -6    -1   -1      0   -1
## 20    0   5    1    0     0    0   0     -1 -10  -4     2    2      0    0
##    pStat1 pSHP2 pZap70 pStat3 pSlp76 pBtk pPlcg2 pErk pLat pS6
## 1      -1     0      0      1      1   -1     -1   -1    0  -2
## 2      -1     0      0      1      1   -1     -1    0    0  -1
## 3       1     0      0      1      0    0      0    0    0  -1
## 4      -2     0      0      0      1   -1      0    0   -1  -1
## 5       0     0      0      0      0    0      1    1    0   0
## 6       0     0      0      0      1    0      0    0    1   0
## 7       0     0      0      0      1   -1      0    0    0   0
## 8      -2     0      0      0      0    0      1    1    0   3
## 9       0     0      0      0      1    0      0    0    0   0
## 10      0     0      0      0      0    0     -1    0    0  -1
## 11      3     0      0      0      0    0      1    0    0   1
## 12     -2     0      0      0      0    0      0    0   -1  -2
## 13     -6     0      0      0      0    0      0    0    0   2
## 14     -1     0      0      1      1   -1     -2   -2   -2  -2
## 15      0     0      0      1      0    0     -2   -1   -1  -2
## 16      1     0      0      0      0    0      0    0    1   0
## 17      0     0      0      0      0    0      0    0    0   0
## 18      1     0      0      0      1    0     -1    0    0   0
## 19     -2     0      0      1      1   -1     -1   -2   -2   0
## 20      1     0      0      0      0    0      0   -1   -2  -1</code></pre>
<p>These labels alone will not be meaningful to non-domain experts, and
in order to assign a cell name to each cluster, one will need to query
an ontology database.</p>
<!-- <br><br> -->
<!-- ### flowCL -->
<!-- flowCL assigns a phenotype to a cell based on its expressed markers - it matches against the [Cell Ontology (CL)](http://cellontology.org). An example query could be "CD16-CD14+CD33+", but it is also possible to use -- and ++ for the marker levels to be more specific regarding the level of a marker. -->
<!-- We can run flowCL directly on the list created using MEM: -->
<!-- ```{r flowCL, fig.keep='all', message=FALSE} -->
<!-- # Adapt label format from numeric to "--", "-", "+". "++" (this is necessary for the "flowcl" package below) -->
<!-- mem <- mem[order(as.numeric(rownames(mem))),] -->
<!-- threshold <- median(abs(as.vector(mem))) -->
<!-- labels <- c() -->
<!-- for(i in 1:nrow(mem)) { -->
<!--   lab <- mem[i,abs(mem[i,])>0] -->
<!--   lab[lab < -threshold] <- "--" -->
<!--   lab[lab < 0] <- "-" -->
<!--   lab[lab > threshold] <- "++" -->
<!--   lab[lab > 0] <- "+" -->
<!--   lab <- paste(names(lab), lab, sep="") -->
<!--   labels <- c(labels, paste(lab, collapse="")) -->
<!-- } -->
<!-- library(flowCL) -->
<!-- res <- flowCL(MarkerList = labels, ExpMrkrLst = list(c(lineage_channels, functional_channels))) -->
<!-- ``` -->
<p><br><br></p>
</div>
</div>
<div id="hierarchies" class="section level2" number="4.6">
<h2><span class="header-section-number">4.6</span> Cellular
hierarchies</h2>
<p>Cells of the immune system exist in a hierarchy of different
developmental and activation states. Estimating and visualizing the
proportion of cells in a complex mixture belonging to different states
can be useful to identify aberrations in cellular differentiation
between different conditions. The spanning-tree progression analysis of
density-normalized events (SPADE) (Qiu et al. 2011) is one of the first
tools to address this problem for mass cytometry data. At the core of
SPADE is a minimum spanning-tree algorithm, which is applied to clusters
of cells to derive possible hierarchies within the data. Events are
clustered using hierarchical clustering after data is downsampled in a
density-dependent manner. This serves to speed up the clustering, but
also ensures equal representation of rare and dense populations. The
clusters in the resulting minimum spanning-tree must then be manually
labelled, but this is aided by plots highlighted by marker intensity for
each sample. Early versions of SPADE relied on stochastic downsampling
and stochastic minimum spanning-trees, which produced different
run-to-run results, but recent updates of the software produces
deterministic results (Qiu 2017). SPADE is implemented in C++, but
exists with an R wrapper.</p>
<p>Wanderlust is a graph-based approach to uncovering cell development
trajectories. It works by first constructing a k-nearest neighbor graph,
connecting each cell to its k nearest neighbors based on Euclidean
distance. Then, the shortest path between an initiator node (a user
selected root cell) and every other cell in the network is used to
estimate the development trajectory of each event (Bendall et al. 2014).
Wanderlust is implemented in Matlab.</p>
<p><br></p>
<div id="flowsom" class="section level3" number="4.6.1">
<h3><span class="header-section-number">4.6.1</span> FlowSOM</h3>
<p>Self-organizing maps (SOM) and minimum spanning tree (MST)
visualizations can be generated using the kohonen package for the SOM,
and the igraph package for the MST. The flowSOM implementations of these
do contain some extra plotting options. If you want visualizations
exactly like those presented in the <a
href="https://doi.org/10.1002/cyto.a.22625">paper</a>, you may try their
<a
href="https://bioconductor.org/packages/release/bioc/html/FlowSOM.html">R
package</a>. Note that it only takes FCS files as input, but individual
functions can be edited if an explicit need for these visualizations
exists.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate and visualize self organizing map with the parameters used by FlowSOM</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kohonen)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>som <span class="ot">&lt;-</span> <span class="fu">som</span>(<span class="fu">as.matrix</span>(sub[,lineage_channels]), <span class="at">grid=</span><span class="fu">somgrid</span>(<span class="at">xdim =</span> <span class="dv">10</span>, <span class="at">ydim =</span> <span class="dv">10</span>), <span class="at">dist.fcts=</span><span class="st">&quot;euclidean&quot;</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate codebook clusters</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ConsensusClusterPlus)</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>nclust <span class="ot">&lt;-</span> <span class="dv">15</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>cclust <span class="ot">&lt;-</span> <span class="fu">ConsensusClusterPlus</span>(<span class="fu">t</span>(som<span class="sc">$</span>codes[[<span class="dv">1</span>]]), <span class="at">maxK =</span> nclust, <span class="at">reps =</span> <span class="dv">100</span>, <span class="at">pItem =</span> <span class="fl">0.9</span>, <span class="at">pFeature =</span> <span class="dv">1</span>, <span class="at">title =</span> <span class="fu">tempdir</span>(), <span class="at">plot =</span> <span class="st">&quot;pdf&quot;</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">clusterAlg =</span> <span class="st">&quot;hc&quot;</span>, <span class="at">distance =</span> <span class="st">&quot;euclidean&quot;</span>, <span class="at">seed =</span> <span class="cn">NULL</span>)</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>codebook_clusters <span class="ot">&lt;-</span> cclust[[nclust]]<span class="sc">$</span>consensusClass</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>codebook_list <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(codebook_clusters)) {</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>  codebook_list[[i]] <span class="ot">&lt;-</span> <span class="fu">names</span>(codebook_clusters[codebook_clusters<span class="sc">==</span>i])</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create minimum spanning tree from codebook distance matrix</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>graph  <span class="ot">&lt;-</span> <span class="fu">graph.adjacency</span>(<span class="fu">as.matrix</span>(<span class="fu">dist</span>(som<span class="sc">$</span>codes[[<span class="dv">1</span>]])), <span class="at">weighted =</span> <span class="cn">TRUE</span>)</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>mst <span class="ot">&lt;-</span> <span class="fu">mst</span>(graph)</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Setup the plot with flowSOM-like MST output</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>layout <span class="ot">&lt;-</span> <span class="fu">layout.kamada.kawai</span>(<span class="fu">as.undirected</span>(mst))</span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>marker_palette <span class="ot">=</span> <span class="fu">colorRampPalette</span>(<span class="fu">brewer.pal</span>(<span class="dv">9</span>, <span class="st">&quot;Set1&quot;</span>))</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>cluster_palette <span class="ot">=</span> <span class="fu">colorRampPalette</span>(<span class="fu">brewer.pal</span>(<span class="dv">8</span>, <span class="st">&quot;Set2&quot;</span>))</span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>marker_cols <span class="ot">&lt;-</span> <span class="fu">marker_palette</span>(<span class="fu">length</span>(lineage_channels))</span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>cluster_cols <span class="ot">&lt;-</span> <span class="fu">cluster_palette</span>(<span class="fu">max</span>(codebook_clusters))</span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>medians <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">apply</span>(som<span class="sc">$</span>codes[[<span class="dv">1</span>]], <span class="dv">1</span>, <span class="cf">function</span>(x) x<span class="sc">/</span><span class="fu">sum</span>(x)))</span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a new vertex shape to iGraph to make star charts</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>mystar <span class="ot">&lt;-</span> <span class="cf">function</span>(coords, <span class="at">v=</span><span class="cn">NULL</span>, params) {</span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a>    vertex.color <span class="ot">&lt;-</span> <span class="fu">params</span>(<span class="st">&quot;vertex&quot;</span>, <span class="st">&quot;color&quot;</span>)</span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">length</span>(vertex.color) <span class="sc">!=</span> <span class="dv">1</span> <span class="sc">&amp;&amp;</span> <span class="sc">!</span><span class="fu">is.null</span>(v)) {</span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a>        vertex.color <span class="ot">&lt;-</span> vertex.color[v]</span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a>    vertex.size    <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">200</span> <span class="sc">*</span> <span class="fu">params</span>(<span class="st">&quot;vertex&quot;</span>, <span class="st">&quot;size&quot;</span>)</span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">length</span>(vertex.size) <span class="sc">!=</span> <span class="dv">1</span> <span class="sc">&amp;&amp;</span> <span class="sc">!</span><span class="fu">is.null</span>(v)) {</span>
<span id="cb55-37"><a href="#cb55-37" aria-hidden="true" tabindex="-1"></a>        vertex.size <span class="ot">&lt;-</span> vertex.size[v]</span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb55-39"><a href="#cb55-39" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">&lt;-</span> <span class="fu">params</span>(<span class="st">&quot;vertex&quot;</span>, <span class="st">&quot;data&quot;</span>)</span>
<span id="cb55-40"><a href="#cb55-40" aria-hidden="true" tabindex="-1"></a>    cP <span class="ot">&lt;-</span> <span class="fu">params</span>(<span class="st">&quot;vertex&quot;</span>,<span class="st">&quot;cP&quot;</span>)</span>
<span id="cb55-41"><a href="#cb55-41" aria-hidden="true" tabindex="-1"></a>    scale <span class="ot">&lt;-</span> <span class="fu">params</span>(<span class="st">&quot;vertex&quot;</span>,<span class="st">&quot;scale&quot;</span>)</span>
<span id="cb55-42"><a href="#cb55-42" aria-hidden="true" tabindex="-1"></a>    bg <span class="ot">&lt;-</span> <span class="fu">params</span>(<span class="st">&quot;vertex&quot;</span>,<span class="st">&quot;bg&quot;</span>)</span>
<span id="cb55-43"><a href="#cb55-43" aria-hidden="true" tabindex="-1"></a>    graphics<span class="sc">::</span><span class="fu">symbols</span>(coords[, <span class="dv">1</span>], coords[, <span class="dv">2</span>], <span class="at">circles =</span> vertex.size,</span>
<span id="cb55-44"><a href="#cb55-44" aria-hidden="true" tabindex="-1"></a>                      <span class="at">inches =</span> <span class="cn">FALSE</span>, <span class="at">bg =</span> bg, <span class="at">bty=</span><span class="st">&#39;n&#39;</span>, <span class="at">add=</span><span class="cn">TRUE</span>)</span>
<span id="cb55-45"><a href="#cb55-45" aria-hidden="true" tabindex="-1"></a>    graphics<span class="sc">::</span><span class="fu">stars</span>(data, <span class="at">locations =</span> coords, <span class="at">labels =</span> <span class="cn">NULL</span>,<span class="at">scale=</span>scale,</span>
<span id="cb55-46"><a href="#cb55-46" aria-hidden="true" tabindex="-1"></a>            <span class="at">len =</span> vertex.size, <span class="at">col.segments =</span> cP,</span>
<span id="cb55-47"><a href="#cb55-47" aria-hidden="true" tabindex="-1"></a>            <span class="at">draw.segments =</span> <span class="cn">TRUE</span>, <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="at">add=</span><span class="cn">TRUE</span>,</span>
<span id="cb55-48"><a href="#cb55-48" aria-hidden="true" tabindex="-1"></a>            <span class="at">inches=</span><span class="cn">FALSE</span>)</span>
<span id="cb55-49"><a href="#cb55-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-50"><a href="#cb55-50" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb55-51"><a href="#cb55-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-52"><a href="#cb55-52" aria-hidden="true" tabindex="-1"></a><span class="fu">add.vertex.shape</span>(<span class="st">&quot;star&quot;</span>, <span class="at">clip=</span>igraph.shape.noclip, <span class="at">plot=</span>mystar,</span>
<span id="cb55-53"><a href="#cb55-53" aria-hidden="true" tabindex="-1"></a>                 <span class="at">parameters=</span><span class="fu">list</span>(<span class="at">vertex.data=</span><span class="cn">NULL</span>,<span class="at">vertex.cP =</span> cluster_cols,</span>
<span id="cb55-54"><a href="#cb55-54" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">vertex.scale=</span><span class="cn">FALSE</span>, <span class="at">vertex.bg =</span> <span class="st">&quot;transparent&quot;</span>))</span>
<span id="cb55-55"><a href="#cb55-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-56"><a href="#cb55-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-57"><a href="#cb55-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate the MST plot</span></span>
<span id="cb55-58"><a href="#cb55-58" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">as.undirected</span>(mst), <span class="at">vertex.shape=</span><span class="st">&quot;star&quot;</span>, <span class="at">vertex.label =</span> <span class="cn">NA</span>, <span class="at">vertex.size =</span> <span class="fu">rep</span>(<span class="dv">10</span>, <span class="fu">length</span>(codebook_clusters)), <span class="at">vertex.data =</span> medians, <span class="at">vertex.cP =</span> <span class="fu">marker_palette</span>(<span class="fu">ncol</span>(medians)), <span class="at">vertex.scale =</span> <span class="cn">TRUE</span>, <span class="at">layout =</span> layout, <span class="at">edge.lty =</span> <span class="dv">1</span>, <span class="at">mark.groups =</span> codebook_list, <span class="at">mark.col =</span> <span class="fu">alpha</span>(cluster_cols,<span class="fl">0.4</span>), <span class="at">mark.border =</span> <span class="cn">NA</span>, <span class="at">mark.shape=</span><span class="dv">1</span>)</span>
<span id="cb55-59"><a href="#cb55-59" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="at">x=</span><span class="fl">1.2</span>,<span class="at">y=</span><span class="fl">1.1</span>,<span class="at">legend=</span>lineage_channels, <span class="at">col=</span>marker_cols, <span class="at">pch=</span><span class="dv">19</span>, <span class="at">cex=</span><span class="fl">0.7</span>, <span class="at">bty=</span><span class="st">&quot;n&quot;</span>, <span class="at">y.intersp=</span><span class="fl">0.8</span>)</span>
<span id="cb55-60"><a href="#cb55-60" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="at">x=</span><span class="sc">-</span><span class="fl">1.8</span>,<span class="at">y=</span><span class="fl">1.1</span>,<span class="at">legend=</span><span class="fu">paste</span>(<span class="st">&quot;cluster&quot;</span>, <span class="dv">1</span><span class="sc">:</span>nclust), <span class="at">col=</span>cluster_cols, <span class="at">pch=</span><span class="dv">19</span>, <span class="at">cex=</span><span class="fl">0.7</span>, <span class="at">bty=</span><span class="st">&quot;n&quot;</span>, <span class="at">y.intersp=</span><span class="fl">0.8</span>)</span></code></pre></div>
<p><img src="cytof_data_scientist_files/figure-html/flowsom%20MST-1.png" width="960" /></p>
<p>Note that this visualization was developed for flow cytometry where
fewer markers are measured. For higher-dimensionality data, such as from
the CyTOF, it can be difficult to discern the expression of the
individual markers, so selecting a subset representing major parent
populations could be useful.</p>
<p><br><br></p>
</div>
</div>
</div>
<div id="analysis-tool-overview" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Analysis tool
overview</h1>
<table>
<colgroup>
<col width="9%" />
<col width="33%" />
<col width="56%" />
</colgroup>
<thead>
<tr class="header">
<th>Tool</th>
<th>Purpose</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CATALYST</td>
<td>Preprocessing</td>
<td><a href="https://doi.org/10.1016/j.cels.2018.02.010">Chevrier et
al. (2018)</a></td>
</tr>
<tr class="even">
<td>premessa</td>
<td>Preprocessing</td>
<td><a href="https://github.com/ParkerICI/premessa">Parker Institute for
Cancer Immunotherapy GitHub</a></td>
</tr>
<tr class="odd">
<td>cyCombine</td>
<td>Batch correction, panel merging</td>
<td><a href="https://doi.org/10.1038/s41467-022-29383-5">Pedersen et
al. (2022)</a></td>
</tr>
<tr class="even">
<td>CytoNorm</td>
<td>Batch correction</td>
<td><a href="https://doi.org/10.1002/cyto.a.23904">Van Gassen et
al. (2019)</a></td>
</tr>
<tr class="odd">
<td>CytofRUV</td>
<td>Batch correction</td>
<td><a href="https://doi.org/10.7554/eLife.59630">Trussart et
al. (2020)</a></td>
</tr>
<tr class="even">
<td>iMUBAC</td>
<td>Batch correction</td>
<td><a href="https://doi.org/10.4049/jimmunol.2000854">Ogishi et
al. (2021)</a></td>
</tr>
<tr class="odd">
<td>CytofBatchAdjust</td>
<td>Batch correction</td>
<td><a href="https://doi.org/10.3389/fimmu.2019.02367">Schuyler et
al. (2019)</a></td>
</tr>
<tr class="even">
<td>Batch-Free Encoding</td>
<td>Batch correction</td>
<td><a href="https://doi.org/10.1101/380816">Shaham (2018)</a></td>
</tr>
<tr class="odd">
<td>SAUCIE</td>
<td>Batch correction, clustering, visualization</td>
<td><a href="https://doi.org/10.1101/237065">Amodio et
al. (2018)</a></td>
</tr>
<tr class="even">
<td>CyTOFmerge</td>
<td>Panel merging</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btz180">Abdelaal et
al. (2019)</a></td>
</tr>
<tr class="odd">
<td>CytoBackBone</td>
<td>Panel merging</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btz212">Pereira et
al. (2019)</a></td>
</tr>
<tr class="even">
<td>CytoRFD</td>
<td>Cell distance measurement</td>
<td><a href="https://doi.org/10.1109/EMBC.2016.7591260">Pouyan et
al. (2016)</a></td>
</tr>
<tr class="odd">
<td>ACDC</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btx054">Lee et
al. (2017)</a></td>
</tr>
<tr class="even">
<td>CytoCompare</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1016/j.ymeth.2017.09.005">Platon et
al. (2018)</a></td>
</tr>
<tr class="odd">
<td>DeepCyTOF</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btx448">Li et
al. (2017)</a></td>
</tr>
<tr class="even">
<td>CyTOF-Linear-Classifier</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1002/cyto.a.23738">Abdelaal et
al. (2019)</a></td>
</tr>
<tr class="odd">
<td>HiPPO and PANDA</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.7287/peerj.preprints.2188v1">Pirrò et
al. (2016)</a></td>
</tr>
<tr class="even">
<td>Mondrian</td>
<td>Cell type assignment</td>
<td><a href="https://arxiv.org/abs/1711.07673">Ji et al. (2017)</a></td>
</tr>
<tr class="odd">
<td>MP (Mondrian)</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1101/414904">Ji et al. (2018)</a></td>
</tr>
<tr class="even">
<td>xCell</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1101/114165">Aran et al. (2017)</a></td>
</tr>
<tr class="odd">
<td>cytometree</td>
<td>Cell type assignment</td>
<td><a href="https://doi.org/10.1002/cyto.a.23601">Commenges et
al. (2018)</a></td>
</tr>
<tr class="even">
<td>SCAFFoLD</td>
<td>Cell type assignment, cellular trajectory mapping</td>
<td><a href="https://doi.org/10.1126/science.1259425">Spitzer et
al. (2015)</a></td>
</tr>
<tr class="odd">
<td>Statistical SCAFFoLD</td>
<td>Cell type assignment, cellular trajectory mapping, differential
abundance analysis</td>
<td><a href="https://doi.org/10.1016/j.cell.2016.12.022">Spitzer et
al. (2017)</a></td>
</tr>
<tr class="even">
<td>DREMI/DREVI</td>
<td>Cellular trajectory detection</td>
<td><a href="https://doi.org/10.1126/science.1250689">Krishnaswamy et
al. (2014)</a></td>
</tr>
<tr class="odd">
<td>Wanderlust</td>
<td>Cellular trajectory detection</td>
<td><a href="https://doi.org/10.1016/j.cell.2014.04.005">Bendall et
al. (2014)</a></td>
</tr>
<tr class="even">
<td>ECLAIR</td>
<td>Cellular trajectory detection</td>
<td><a href="https://doi.org/10.1093/nar/gkw452">Giecold et
al. (2016)</a></td>
</tr>
<tr class="odd">
<td>TreeTop</td>
<td>Cellular trajectory detection</td>
<td><a href="https://doi.org/10.1101/200923">Macnair et
al. (2017)</a></td>
</tr>
<tr class="even">
<td>Wishbone</td>
<td>Cellular trajectory detection</td>
<td><a href="https://doi.org/10.1038/nbt.3569">Setty et
al. (2016)</a></td>
</tr>
<tr class="odd">
<td>PP-SLIDE</td>
<td>Cellular trajectory detection (prediction of precursor cells)</td>
<td><a href="https://doi.org/10.1016/j.celrep.2017.06.087">Cavrois et
al. (2017)</a></td>
</tr>
<tr class="even">
<td>ACCENSE</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1073/pnas.1321405111">Shekhar et
al. (2014)</a></td>
</tr>
<tr class="odd">
<td>DensVM</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1038/ni.3006">Becher et
al. (2014)</a></td>
</tr>
<tr class="even">
<td>FlowSOM</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1002/cyto.a.22625">Van Gassen et
al. (2015)</a></td>
</tr>
<tr class="odd">
<td>PhenoGraph</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1016/j.cell.2015.05.047">Levine et
al. (2015)</a></td>
</tr>
<tr class="even">
<td>SPADE</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1038/nbt.1991">Qui et
al. (2011)</a></td>
</tr>
<tr class="odd">
<td>X-Shift</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1038/nmeth.3863">Samusik et
al. (2016)</a></td>
</tr>
<tr class="even">
<td>ClusterX</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1371/journal.pcbi.1005112">Chen et
al. (2016)</a></td>
</tr>
<tr class="odd">
<td>FlowGrid</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1101/394189">Ye &amp; Ho (2018)</a></td>
</tr>
<tr class="even">
<td>Rclusterpp</td>
<td>Clustering</td>
<td><a href="https://github.com/nolanlab/Rclusterpp">Nolan Lab
GitHub</a></td>
</tr>
<tr class="odd">
<td>CCAST</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1371/journal.pcbi.1003664">Anhang et
al. (2014)</a></td>
</tr>
<tr class="even">
<td>Convex clustering</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1111/rssb.12226">Radchenko &amp;
Mukherjee (2017)</a></td>
</tr>
<tr class="odd">
<td>CytoSPADE</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1093/bioinformatics/bts425">Linderman et
al. (2012)</a></td>
</tr>
<tr class="even">
<td>densityCUT</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btw227">Ding et
al. (2016)</a></td>
</tr>
<tr class="odd">
<td>DEPECHE</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1101/396135">Theorell et
al. (2018)</a></td>
</tr>
<tr class="even">
<td>flowMEANS</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1002/cyto.a.21007">Aghaeepour et
al. (2011)</a></td>
</tr>
<tr class="odd">
<td>immunoCLUST</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1002/cyto.a.22626">Sörensen et
al. (2015)</a></td>
</tr>
<tr class="even">
<td>OpenCyto</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1371/journal.pcbi.1003806">Finak et
al. (2014)</a></td>
</tr>
<tr class="odd">
<td>PAC-MAN</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1371/journal.pcbi.1005875">Pezzotti et
al. (2017)</a></td>
</tr>
<tr class="even">
<td>SOPHE</td>
<td>Clustering</td>
<td><a href="https://doi.org/10.1002/cyto.a.22704">Zaunders et
al. (2015)</a></td>
</tr>
<tr class="odd">
<td>Citrus</td>
<td>Clustering, differential abundance analysis</td>
<td><a href="https://doi.org/10.1073/pnas.1408792111">Bruggner et
al. (2014)</a></td>
</tr>
<tr class="even">
<td>Cydar</td>
<td>Clustering, differential abundance analysis</td>
<td><a href="https://doi.org/10.1038/nmeth.4295">Lun et
al. (2017)</a></td>
</tr>
<tr class="odd">
<td>diffcyt</td>
<td>Clustering, differential abundance analysis</td>
<td><a href="https://doi.org/10.1101/349738">Weber et
al. (2018)</a></td>
</tr>
<tr class="even">
<td>RchyOptimyx</td>
<td>Clustering, simulating manual gating</td>
<td><a href="https://doi.org/10.1002/cyto.a.22209">Aghaeepour et
al. (2012)</a> and <a
href="https://doi.org/10.1093/bioinformatics/btt770">O’Neill et
al. (2014)</a></td>
</tr>
<tr class="odd">
<td>MAGAN</td>
<td>Comparison of different types of measurements</td>
<td><a href="https://arxiv.org/abs/1803.00385">Amodio &amp; Krishnaswamy
(2018)</a></td>
</tr>
<tr class="even">
<td>MetaCYTO</td>
<td>Comparison of different types of measurements</td>
<td><a href="https://doi.org/10.1016/j.celrep.2018.07.003">Hu et
al. (2018)</a></td>
</tr>
<tr class="odd">
<td>Sensitivity Analysis</td>
<td>Covariance of markers</td>
<td><a href="https://arxiv.org/abs/1308.2329">G’Sell et
al. (2013)</a></td>
</tr>
<tr class="even">
<td>Stochastic Bayes</td>
<td>Covariance of markers</td>
<td><a href="https://arxiv.org/abs/1509.01631">Knowles (2015)</a></td>
</tr>
<tr class="odd">
<td>CellCnn</td>
<td>Detection of disease-associated cell subsets</td>
<td><a href="https://doi.org/10.1038/ncomms14825">Arvanti &amp; Claassen
(2017)</a></td>
</tr>
<tr class="even">
<td>t-SNE</td>
<td>Dimensionality reduction</td>
<td><a href="https://www.jmlr.org/papers/v9/vandermaaten08a.html">van
der Maaten et al. (2008)</a></td>
</tr>
<tr class="odd">
<td>PCA</td>
<td>Dimensionality reduction</td>
<td></td>
</tr>
<tr class="even">
<td>A-tSNE</td>
<td>Dimensionality reduction</td>
<td><a href="https://doi.org/10.1109/TVCG.2016.2570755">Li et
al. (2017)</a></td>
</tr>
<tr class="odd">
<td>CytoBinning</td>
<td>Dimensionality reduction</td>
<td><a href="https://doi.org/10.1101/321893">Shen et al. (2018)</a></td>
</tr>
<tr class="even">
<td>destiny</td>
<td>Dimensionality reduction</td>
<td><a href="https://doi.org/10.1093/bioinformatics/btv715">Angerer et
al. (2015)</a></td>
</tr>
<tr class="odd">
<td>Cluster‐to‐Gate</td>
<td>Gating hierarchy generation</td>
<td><a href="https://doi.org/10.1002/cyto.a.23577">Yang &amp; Qui
(2018)</a></td>
</tr>
<tr class="even">
<td>Hypergate</td>
<td>Gating hierarchy generation</td>
<td><a href="https://doi.org/10.1093/bioinformatics/bty491">Becht et
al. (2018)</a></td>
</tr>
<tr class="odd">
<td>treeclimbR</td>
<td>Gating hierarchy generation</td>
<td><a href="https://doi.org/10.1186/s13059-021-02368-1">Huang et
al. (2021)</a></td>
</tr>
<tr class="even">
<td>QFMatch</td>
<td>Matching of cell clusters between samples</td>
<td><a href="https://doi.org/10.1038/s41598-018-21444-4">Orlova et
al. (2018)</a></td>
</tr>
<tr class="odd">
<td>Hierarchical Bayesian</td>
<td>Network modeling</td>
<td><a href="https://doi.org/10.4137/CIN.S13984">Mitra et
al. (2014)</a></td>
</tr>
<tr class="even">
<td>SCENERY</td>
<td>Network modeling</td>
<td><a href="https://doi.org/10.1093/nar/gkx448">Papoutsoglou et
al. (2017)</a></td>
</tr>
<tr class="odd">
<td>CellCycleTRACER</td>
<td>Normalization of cell-cycle and cell-volume effects</td>
<td><a href="https://doi.org/10.1038/s41467-018-03005-5">Rapsomaniki et
al. (2018)</a></td>
</tr>
<tr class="even">
<td>GateFinder</td>
<td>Simulating manual gating</td>
<td><a href="https://doi.org/10.1093/bioinformatics/bty430">Aghaeepour
et al. (2018)</a></td>
</tr>
<tr class="odd">
<td>PHATE</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1101/120378">Moon et al. (2018)</a></td>
</tr>
<tr class="even">
<td>Radviz</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1002/cyto.b.21499">Abraham et
al. (2016)</a></td>
</tr>
<tr class="odd">
<td>Penalized supervised star plot</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1089/vim.2018.0046">Holmes et
al. (2019)</a></td>
</tr>
<tr class="even">
<td>Sconify</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1101/337485">Burns et
al. (2018)</a></td>
</tr>
<tr class="odd">
<td>Cytosplore</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1111/cgf.12893">Höllt et
al. (2016)</a></td>
</tr>
<tr class="even">
<td>CyteGuide</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1109/TVCG.2017.2744318">Höllt et
al. (2017)</a></td>
</tr>
<tr class="odd">
<td>NetworkPainter</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1186/s12859-015-0602-4">Karr et
al. (2015)</a></td>
</tr>
<tr class="even">
<td>SLIDE</td>
<td>Visualization</td>
<td><a href="https://doi.org/10.1016/j.ymeth.2015.07.008">Sen et
al. (2015)</a></td>
</tr>
</tbody>
</table>
<div id="sessioninfo" class="section level4" number="5.0.0.1">
<h4><span class="header-section-number">5.0.0.1</span> R session
info</h4>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code></pre></div>
<pre><code>## R version 4.1.1 (2021-08-10)
## Platform: x86_64-apple-darwin17.0 (64-bit)
## Running under: macOS Big Sur 10.16
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] da_DK.UTF-8/da_DK.UTF-8/da_DK.UTF-8/C/da_DK.UTF-8/da_DK.UTF-8
## 
## attached base packages:
## [1] splines   stats4    stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] igraph_1.3.0                ConsensusClusterPlus_1.58.0
##  [3] kohonen_3.0.11              MEM_2.0.0                  
##  [5] ncdfFlow_2.40.0             BH_1.78.0-0                
##  [7] RcppArmadillo_0.11.0.0.0    cydar_1.18.0               
##  [9] SingleCellExperiment_1.16.0 edgeR_3.36.0               
## [11] limma_3.50.1                HDCytoData_1.14.0          
## [13] SummarizedExperiment_1.24.0 Biobase_2.54.0             
## [15] GenomicRanges_1.46.1        GenomeInfoDb_1.30.1        
## [17] IRanges_2.28.0              S4Vectors_0.32.4           
## [19] MatrixGenerics_1.6.0        matrixStats_0.61.0         
## [21] ExperimentHub_2.2.1         AnnotationHub_3.2.2        
## [23] BiocFileCache_2.2.1         dbplyr_2.1.1               
## [25] BiocGenerics_0.40.0         VCA_1.4.3                  
## [27] JPEN_1.0                    mvtnorm_1.1-3              
## [29] plotrix_3.8-2               matrixcalc_1.0-5           
## [31] dplyr_1.0.8                 Radviz_0.9.3               
## [33] gplots_3.1.1                miscTools_0.6-26           
## [35] cytofkit2_0.99.80           VGAM_1.1-6                 
## [37] reticulate_1.24             plyr_1.8.7                 
## [39] uwot_0.1.11                 Matrix_1.4-1               
## [41] Rtsne_0.15                  cyCombine_0.2.1            
## [43] ggridges_0.5.3              reshape2_1.4.4             
## [45] cowplot_1.1.1               ggplot2_3.3.5              
## [47] RColorBrewer_1.1-3          MASS_7.3-56                
## [49] flowCore_2.6.0             
## 
## loaded via a namespace (and not attached):
##   [1] rappdirs_0.3.3                scattermore_0.8              
##   [3] flowWorkspace_4.6.0           tidyr_1.2.0                  
##   [5] bit64_4.0.5                   knitr_1.38                   
##   [7] irlba_2.3.5                   multcomp_1.4-18              
##   [9] DelayedArray_0.20.0           data.table_1.14.2            
##  [11] KEGGREST_1.34.0               RCurl_1.98-1.6               
##  [13] doParallel_1.0.17             generics_0.1.2               
##  [15] ScaledMatrix_1.2.0            TH.data_1.1-0                
##  [17] RSQLite_2.2.12                RANN_2.6.1                   
##  [19] proxy_0.4-26                  ggpointdensity_0.1.0         
##  [21] bit_4.0.4                     tzdb_0.3.0                   
##  [23] xml2_1.3.3                    httpuv_1.6.5                 
##  [25] assertthat_0.2.1              isoband_0.2.5                
##  [27] viridis_0.6.2                 xfun_0.30                    
##  [29] hms_1.1.1                     jquerylib_0.1.4              
##  [31] evaluate_0.15                 promises_1.2.0.1             
##  [33] fansi_1.0.3                   caTools_1.18.2               
##  [35] readxl_1.4.0                  Rgraphviz_2.38.0             
##  [37] DBI_1.1.2                     CATALYST_1.18.1              
##  [39] htmlwidgets_1.5.4             purrr_0.3.4                  
##  [41] ellipsis_0.3.2                RSpectra_0.16-0              
##  [43] ggcyto_1.22.0                 ggnewscale_0.4.7             
##  [45] ggpubr_0.4.0                  backports_1.4.1              
##  [47] cytolib_2.6.2                 permute_0.9-7                
##  [49] annotate_1.72.0               sparseMatrixStats_1.6.0      
##  [51] RcppParallel_5.1.5            vctrs_0.4.0                  
##  [53] abind_1.4-7                   cachem_1.0.6                 
##  [55] withr_2.5.0                   ggforce_0.3.3                
##  [57] aws.signature_0.6.0           vegan_2.5-7                  
##  [59] cluster_2.1.3                 crayon_1.5.1                 
##  [61] drc_3.0-1                     genefilter_1.76.0            
##  [63] pkgconfig_2.0.3               labeling_0.4.2               
##  [65] tweenr_1.0.2                  vipor_0.4.5                  
##  [67] nlme_3.1-157                  rlang_1.0.2                  
##  [69] lifecycle_1.0.1               miniUI_0.1.1.1               
##  [71] sandwich_3.0-1                colourpicker_1.1.1           
##  [73] filelock_1.0.2                rsvd_1.0.5                   
##  [75] cellranger_1.1.0              polyclip_1.10-0              
##  [77] shinyFiles_0.9.1              graph_1.72.0                 
##  [79] carData_3.0-5                 boot_1.3-28                  
##  [81] zoo_1.8-9                     beeswarm_0.4.0               
##  [83] base64enc_0.1-3               GlobalOptions_0.1.2          
##  [85] pheatmap_1.0.12               viridisLite_0.4.0            
##  [87] png_0.1-7                     rjson_0.2.21                 
##  [89] bitops_1.0-7                  KernSmooth_2.23-20           
##  [91] Biostrings_2.62.0             DelayedMatrixStats_1.16.0    
##  [93] blob_1.2.2                    shape_1.4.6                  
##  [95] stringr_1.4.0                 readr_2.1.2                  
##  [97] jpeg_0.1-9                    rstatix_0.7.0                
##  [99] ggsignif_0.6.3                beachmat_2.10.0              
## [101] aws.s3_0.3.21                 scales_1.1.1                 
## [103] memoise_2.0.1                 magrittr_2.0.3               
## [105] hexbin_1.28.2                 zlibbioc_1.40.0              
## [107] compiler_4.1.1                lme4_1.1-28                  
## [109] clue_0.3-60                   cli_3.2.0                    
## [111] XVector_0.34.0                FlowSOM_2.2.0                
## [113] mgcv_1.8-40                   tidyselect_1.1.2             
## [115] stringi_1.7.6                 forcats_0.5.1                
## [117] RProtoBufLib_2.6.0            highr_0.9                    
## [119] yaml_2.3.5                    BiocSingular_1.10.0          
## [121] askpass_1.1                   locfit_1.5-9.5               
## [123] latticeExtra_0.6-30           ggrepel_0.9.1                
## [125] grid_4.1.1                    sass_0.4.1                   
## [127] tools_4.1.1                   parallel_4.1.1               
## [129] rio_0.5.29                    CytoML_2.6.0                 
## [131] circlize_0.4.14               rstudioapi_0.13              
## [133] foreach_1.5.2                 foreign_0.8-82               
## [135] gridExtra_2.3                 farver_2.1.0                 
## [137] BiocManager_1.30.16           digest_0.6.29                
## [139] shiny_1.7.1                   Rcpp_1.0.8.3                 
## [141] car_3.0-12                    broom_0.7.12                 
## [143] scuttle_1.4.0                 BiocVersion_3.14.0           
## [145] later_1.3.0                   RcppAnnoy_0.0.19             
## [147] httr_1.4.2                    AnnotationDbi_1.56.2         
## [149] ComplexHeatmap_2.10.0         colorspace_2.0-3             
## [151] XML_3.99-0.9                  fs_1.5.2                     
## [153] pdist_1.2                     umap_0.2.8.0                 
## [155] statmod_1.4.36                RBGL_1.70.0                  
## [157] scater_1.22.0                 xtable_1.8-6                 
## [159] nloptr_2.0.0                  jsonlite_1.8.0               
## [161] R6_2.5.1                      pillar_1.7.0                 
## [163] htmltools_0.5.2               mime_0.12                    
## [165] minqa_1.2.4                   nnls_1.4                     
## [167] glue_1.6.2                    fastmap_1.1.0                
## [169] BiocParallel_1.28.3           BiocNeighbors_1.12.0         
## [171] interactiveDisplayBase_1.32.0 class_7.3-20                 
## [173] codetools_0.2-18              utf8_1.2.2                   
## [175] lattice_0.20-45               bslib_0.3.1                  
## [177] tibble_3.1.6                  sva_3.42.0                   
## [179] numDeriv_2020.2-1             ggbeeswarm_0.6.0             
## [181] curl_4.3.2                    colorRamps_2.3               
## [183] gtools_3.9.2                  zip_2.2.0                    
## [185] openxlsx_4.2.5                openssl_2.0.0                
## [187] survival_3.3-1                rmarkdown_2.13               
## [189] munsell_0.5.0                 e1071_1.7-9                  
## [191] GetoptLong_1.0.5              GenomeInfoDbData_1.2.7       
## [193] iterators_1.0.14              haven_2.4.3                  
## [195] gtable_0.3.0</code></pre>
</div>
</div>

&nbsp;
<hr />
<p style="text-align: center;">Contact</p>

<!-- Add icon library -->
<script src="https://kit.fontawesome.com/2089613833.js" crossorigin="anonymous"></script>

<!-- Add font awesome icons -->
<p style="text-align: center;">
    <a href="mailto:lronn@dtu.dk" class="fas fa-envelope"></a>
    <a href="https://www.linkedin.com/in/larsronnolsen/" class="fab fa-linkedin-in"></a>
    <a href="https://github.com/biosurf/" class="fab fa-github"></a>
</p>

&nbsp;


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
